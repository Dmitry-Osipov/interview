# Мониторинг и профилирование
## Оглавление
- [Мониторинг](#мониторинг)
- [Профилирование](#профилирование)
## Мониторинг
Мониторинг предполагает, что мы будем присматривать за работающим приложением на основе выборки данных 
(CPU, использование памяти, т.д.).

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8d3/35f/519/8d335f51913931033067126d92eedc38.png)

(Мониторинг кучи в Spring Boot kotlin grafana демонстрирует точку данных, выбранную с заданной детализацией. Судя по 
данным, происходит что-то заметное, но насколько это серьёзно?)

Таким образом, на практике данные в режиме реального времени не интерпретируются. Данные для мониторинга собираются 
путем выборке, поэтому, по сути процесса, некоторые существенные значения могут в них отсутствовать. Еще менее 
детализированные данные вообще могут выглядеть совсем иначе, чем хорошо детализированные. Тем не менее, 
предложенный процесс выборки данных достаточно хорош, чтобы организовать на его основе тревожные оповещения, 
поскольку здесь предусмотрено пороговое значение. Наш механизм позволяет что-либо предпринять, пока еще не слишком 
поздно (на рисунке 6 показано, как растет время, затрачиваемое на отклики и на выделение памяти). В процессе 
мониторинга усваиваем: если понимать ограничения приложений, то удобно определять информативные пороги, 
переходить которые нельзя.
## Профилирование
С другой стороны, профилирование приложения позволяет внимательнее заглянуть в самое сердце приложения. Данные 
поступают почти в режиме реального времени, поэтому могут высветить проблемы, связанные с недостаточным выделением и 
использованием памяти.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/eb2/638/d8e/eb2638d8e00013b02b8a43a0be73174c.png)

(При помощи Java Flight Recorder зафиксированы сложности с работой сборщика мусора в каждом из подов)

При помощи профилирования можно внимательно рассмотреть, как обстоит дело с возвращением памяти в работу, то есть,
со сборкой мусора. Пожалуй, наилучший инструмент для этого - Java Flight Recorder(JFR), сделанный в составе проекта 
Java Mission Control (JMC). Применяя JRE, можно поднять его внутреннюю аналитику, наблюдая за выдачей событий со 
стороны JFR. Давайте им пользоваться, ведь он есть в открытом доступе со времен Java SE 11, а все примеры работают 
на OpenJDK 17.

Управление памятью на платформе Java – тема интереснейшая, но пока достаточно сказать, что одна из ее целей – 
уменьшить, насколько это возможно, количество циклов работы у сборщика мусора и оставить между ними как можно более 
короткие паузы. Длинные паузы или множество кратких пауз могут вызывать проблемы с временем отклика приложений,
из-за чего возможны различные нежелательные состояния.

Профилирование может дать нам хорошие подсказки и подвести прямо к первопричинам. При помощи профилирования можно
целенаправленно сделать выборку потоков приложений и внимательно рассмотреть каждый из них.

Анализируя поведение потоков, можно выявить те или иные подозрительные действия, происходящие за кулисами и невидимые
при мониторинге, либо при тестировании приложения вручную, либо при нагрузочном тестировании. В целом может оказаться
довольно непросто отыскать в коде импортированной библиотеки конкретную проблему, тем более, что работа идет в кэше, 
расположенном прямо в памяти.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/71c/19c/ae4/71c19cae446cb00e312e69703a64f42e.png)

(Подсвечен активный метод, из-за которого возникли проблемы. Мы смогли его обнаружить, проанализировав записи Java 
Flight, сделанные на основе целенаправленно выбранных потоков.)
