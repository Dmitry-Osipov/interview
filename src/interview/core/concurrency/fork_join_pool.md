# ForkJoinPool
## Оглавление
- [Описание](#описание)
- [API](#api)
- [Балансировка задач: подходы](#балансировка-задач-подходы)
- [Балансировка задач: Work stealing](#балансировка-задач-work-stealing)
- [Балансировка задач: submit](#балансировка-задач-submit)
- [Типичная задача: for().join()](#типичная-задача-forkjoin)
- [Типичная задача: join()](#типичная-задача-join)
- [Главный козырь: идеи](#главный-козырь-идеи)
- [Выбор ширины: проблема](#выбор-ширины-проблема)
- [Выбор ширины: наивный подход](#выбор-ширины-наивный-подход)
- [Выбор ширины: правильный подход](#выбор-ширины-правильный-подход)
## Описание
Принцип работы базируется на стратегии "разделяй и властвуй". Сначала у нас есть задача, которая должна быть выполнена, 
затем мы разделяем её на маленькие более простые задачи, выполняем эти самые задачи, затем соединяем всё назад.
## API
ForkJoinPool:
- ... extends ExecutorService
- принимает в себя Runnable, Callable
- работает как обычный пул

ForkJoinTask<V>:
- общий предок всех задач в FJP
- удобнее стандартные подклассы
- RecursiveTask<V> - подкласс, который возвращает результат
- RecursiveAction - подкласс, который не возвращает результат

```java
import java.util.concurrent.ForkJoinPool;

ForkJoinPool fjp = new ForkJoinPool();
Future<?> future1 = fjp.submit(new Runnable(){...});
Future<T> future2 = fjp.invoke(new Callable<>(){...});
Future<T> future3 = fjp.invoke(new RecursiveTask<>(){...});
```
## Балансировка задач: подходы
- балансировка хорошо решается в динамике
- три базовых подхода
  - Work arbitrage: общий арбитр, раздающий задачи; часто обычная blocking queue
  - Work dealing: у каждого свой набор задач, перегруженные потоки отдают свои задачи на сторону
  - Work stealing: у каждого свой набор задач, свободные потоки "крадут" задачи у перегруженных
## Балансировка задач: Work stealing
- Локальная очередь для каждого потока
  - lock-free WorkQueue ~ ForkJoin Task<?>[]
  - тщательно изолирована от остальных данных
- Владелец работает с головой очереди
  - без синхронизации
- Другие потоки могут "тырить" из хвоста
  - "stealing" с минимальной синхронизацией 
## Балансировка задач: submit
- Куда происходит submit() внешних задач?
  - в голову случайной очереди? Синхронизация
  - в хвост случайной очереди? FIFO
- Отдельная очередь для внешних задач?
- Расклеить очереди входных задач
## Типичная задача: fork().join()
- fork()
  - кладёт в очередь и возвращается
  - даёт возможность "украсть" задачу
- join()
  - "ждать, пока закончится"
  - даёт возможность занять поток ещё чем-нибудь
## Типичная задача: join()
Можно сделать одно из действий:
- выполнить эту join-ящуюся задачу
- найти в очереди задачу и выполнить
- пойти в чужую очередь и "украсть" задачу
- ...
- заблокироваться
## Главный козырь: идеи
- обычно в локальной очереди куча задач
- почти все потоки почти всегда заняты
- балансировка требуется редко
- "украденная" задача засевает очередь
## Выбор ширины: проблема
Как выбрать THRESHOLD (лимит, с которого начинаем разбивать задачи)? Если будет слишком маленький, то получим кучу 
объектов-задач, а если слишком большой, то будет мало параллелизма
## Выбор ширины: наивный подход
T = N / C, где N - размер задачи, C - количество CPU (воркеров).

Данный вариант плохо работает при неравномерных задачах, несимметричных потоках, непредсказуемых задержках.
## Выбор ширины: правильный подход
T = N / C * L, где N - размер задачи, C - количество CPU, L - load factor.

Load factor даёт "запас" задач, которые амортизируют задержки и неравномерности. Обычное значение от 10 до 100.