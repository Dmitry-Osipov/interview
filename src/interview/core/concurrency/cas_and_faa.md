# Compare And Swap, Fetch And Add
## Оглавление
- [Определение CAS и FAA](#определение-cas-и-faa)
- [Описание CAS](#описание-cas)
- [Преимущества и недостатки CAS](#преимущества-и-недостатки-cas)
- [Описание FAA](#описание-faa)
- [Преимущества и недостатки FAA](#преимущества-и-недостатки-faa)
- [Краткий обзор применения CAS и FAA](#краткий-обзор-применения-cas-и-faa)
- [Пропускная способность и масштабируемость](#пропускная-способность-и-масштабируемость)
- [Сценарии использования CAS и FAA](#сценарии-использования-cas-и-faa)
- [Дополнительно](#дополнительно)
## Определение CAS и FAA
CAS (Compare-and-Swap) и FAA (Fetch-and-Add) являются атомарными операциями, предназначенными для обеспечения
потокобезопасности и синхронизации в многопоточных приложениях. CAS позволяет сравнить значение переменной с ожидаемым 
значением и, если сравнение проходит успешно, атомарно обновить его. FAA предоставляет атомарное инкрементирование или 
декрементирование переменных, что делает его идеальным для счетчиков и агрегаторов.
## Описание CAS
Операция CAS включает 3 объекта-операнда: адрес ячейки памяти (_V_), ожидаемое старое значение (_A_) и новое значение 
(_B_). Процессор атомарно обновляет адрес ячейки (_V_), если значение в ячейке памяти совпадает со старым ожидаемым 
значением(_A_), иначе изменения не зафиксируется. В любом случае, будет выведена величина, которая предшествовала 
времени запроса. Некоторые варианты метода CAS просто сообщают, успешно ли прошла операция, вместо того, чтобы 
отобразить само текущее значение. Фактически, CAS только сообщает: «Наверное, значение по адресу _V_ равняется _A_; 
если так оно и есть, поместите туда же _B_, в противном случае не делайте этого, но обязательно скажите мне, 
какая величина — текущая.»

Самым естественным методом использования CAS для синхронизации будет чтение значения _A_ со значением адреса _V_, 
проделать многошаговое вычисление для получения нового значения _B_, и затем воспользоваться методом CAS для замены 
значения параметра _V_ с прежнего, _A_, на новое, _B_. CAS выполнит задание, если _V_ за это время не менялось. Что, 
собственно говоря, наблюдается в JDK 7:
```java
public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }
public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
```
Где сам метод — unsafe.compareAndSwapInt является native, выполняется на процессоре атомарно и на ассемблере выглядит 
следующим образом, если включить распечатку ассемблерного кода:
```
lock cmpxchg [esi+0xC], ecx
```
Инструкция выполняется следующим образом: читается значение из области памяти, указанное первым операндом и блокировка 
шины после чтения не снимается. Затем происходит сравнение значения по адресу памяти с регистром eax, где хранится 
ожидаемое старое значение, и если они были равны, то процессор записывает значение второго операнда (регистр ecx) в 
область памяти, указанную первым операндом. По завершении записи блокировка шины снимается. Особенности x86 в этом, 
что запись происходит в любом случае, за тем небольшим исключением, что если значения были не равны, то в область 
памяти заносится значение, которое было получено на этапе чтения из этой же области памяти.

Таким образом мы получаем работу в цикле с проверкой переменной, причем которая может окончиться неудачей и всю работу 
в цикле до проверки необходимо начинать заново.
## Преимущества и недостатки CAS
Преимущества:
- Быстрая и низкозатратная операция по сравнению с традиционными механизмами блокировки
- Неблокирующий подход, который уменьшает вероятность взаимных блокировок и улучшает производительность приложения
- Позволяет реализовать оптимистичные стратегии синхронизации, которые могут работать эффективно в условиях низкой 
конкуренции между потоками

Недостатки:
- Может приводить к голоданию потоков (starvation)
- Может приводить к "проблеме АВА", когда значение переменной меняется с А на В, а затем обратно на А, что может 
привести к ошибкам в некоторых алгоритмах
- Требует знания и опыта для корректной реализации алгоритмов, особенно при решении проблемы АВА
## Описание FAA
Fetch-and-Add работает проще и не содержит никаких циклов (в архитектуре Intel осуществляется группой команд xadd). 
Также он включает 2 объекта-операнда: адрес ячейки памяти (_V_) и значение (_S_), на которое следует увеличить старое 
значение, хранимое по адресу памяти (_V_). Так, FAA можно описать в таком виде: получить значение, располагаемое по 
указанному адресу (_V_) и сохранить его временно. Затем в указанный адрес (_V_) занести сохраненное ранее значение, 
увеличенное на значение, которое из себя представляет 2 объект-операнд (_S_). Причем, все указанные выше операции 
выполняются атомарно и реализованы на аппаратном уровне.

В JDK 8 код выглядит так:
```java
public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }

public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
      var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
  }
```
«Ноо, — скажете Вы, — чем данная реализация отличается от 7 версии»?

Тут приблизительно такой же цикл и все выполняется схожим образом. Однако, тот код, который вы видите и написан на Java 
не выполняется в конечном итоге на процессоре. Тот код, который связан с циклом и установкой нового значения заменяется 
в конечном итоге на одну операцию ассемблера:
```
lock xadd [esi+0xC], eax
```
Где, соответственно, в регистре eax хранится значение, на которое нужно будет увеличить старое значение, хранимое по 
адресу [esi+0xC]. Повторюсь, все выполняется атомарно. Но такой фокус сработает, если у Вас 8 версия JDK, иначе 
выполнится обычный CAS.
## Преимущества и недостатки FAA
Преимущества:
- Быстрая и низкозатратная операция по сравнению с традиционными механизмами блокировки
- Неблокирующий подоход, что снижает вероятность возникновения взаимных блокировок и улучшает производительность 
приложения
- Упрощает реализацию атомарных счётчиков и агрегаторов, таких как LongAdder и DoubleAdder

Недостатки:
- Может не подходить для всех сценариев использования, так как подразумевает атомарное увеличение на заданное число, что 
может быть не универсальным решением для всех задач
- Требует определённого опыта и знаний для корректной реализации алгоритмов, особенно в условиях высокой конкуренции 
между потоками
## Краткий обзор применения CAS и FAA
CAS и FAA широко используются для реализации различных многопоточных структур данных и алгоритмов. В Java, например,
CAS используется в классах, таких как AtomicInteger, AtomicLong и AtomicReference, для предоставления потокобезопасных
атомарных операций на базовых типах данных. FAA используется в классах LongAdder и DoubleAdder для эффективного
инкрементирования переменных с учетом масштабируемости
## Пропускная способность и масштабируемость
CAS и FAA обеспечивают высокую пропускную способность и масштабируемость по сравнению с традиционными механизмами 
блокировки. Однако, из-за различий в сценариях использования и характеристик операций, пропускная способность и 
масштабируемость могут варьироваться.

В случае CAS, пропускная способность может снижаться при высокой конкуренции между потоками из-за частых неудачных 
попыток обновления. FAA обычно имеет лучшую пропускную способность и масштабируемость, особенно при использовании 
классов, таких как LongAdder и DoubleAdder, которые разрабатывались для уменьшения соперничества между потоками.
## Сценарии использования CAS и FAA
CAS:
- Реализация неблокирующих структур данных, таких как стеки, очереди и списки.
- Реализация оптимистичных стратегий синхронизации, где конкуренция между потоками низкая или средняя.
- Решение проблем, связанных с блокировками и взаимными блокировками в многопоточных приложениях.

FAA:
- Реализация потокобезопасных счетчиков и агрегаторов, где высокая производительность и масштабируемость являются критическими факторами.
- Решение задач, где требуется атомарное инкрементирование или декрементирование переменных.
- Реализация накопительных счетчиков в системах мониторинга и статистики.
## Дополнительно
1) CAS является «оптимистичным» алгоритмом и допускает невыполнение операции, в то время как FAA нет. У FAA нет явной
   лазейки в виде уязвимости из-за удаленного вмешательства, следовательно, нет необходимости в цикле для повторных
   попыток.
2) Если вы применяете стандартный CAS подход, предполагая, что ваша система использует наиболее популярную реализацию
   когерентности через snoop-base или «подслушивание», то это может вызвать read-to-share транзакцию, чтобы получить
   основную строку кэша или состояние E. CAS операция, по сути, переводит кэш линию в состояние M (Modified), для чего
   может потребоваться дополнительная транзакция. Таким образом, в самом худшем случае стандартный CAS подход может
   подвергнуть шину двум транзакциям, но реализация Fetch-And-Add будет стремиться провести передачу линии непосредственно
   до M состояния. В процессе вы бы могли спекулировать значениями и получать короткий путь без предварительных загрузок,
   как это пытается получить «голый» CAS. К тому же, это возможно при сложных реализациях процессора для выполнения
   согласованных операций и целевого исследования линии в M состоянии. Наконец, в некоторых случаях можно успешно
   вставить инструкцию предвыборки-для-записи (PREFETCHW) перед выполнением операций, чтобы избежать транзакции обновления.
   Но этот подход должен быть применен с особым вниманием, так как в некоторых случаях это может принести больше вреда,
   чем пользы. Учитывая все это, FAA, где это возможно, имеет преимущество. Другими словами - что для того, чтобы сделать
   CAS нужно загрузить старое значение из памяти, что даёт два обращения к памяти, а чтобы сделать xadd старое значение
   загружать не нужно, и обращение к памяти нужно только одно.
3) Допустим, вы пытаетесь увеличить переменную (например, инкрементировать) с помощью CAS цикла. Когда CAS начинает
   сбиваться достаточно часто, можно обнаружить, что ветвь для выхода из цикла (обычно возникает при отсутствии или легкой
   нагрузке) начинает прогнозировать ошибочные пути, которые прогнозируют нам, что мы останемся в петле. Поэтому, когда
   CAS в конечном счете достигнет цели, вы словите branch mispredict (ошибочное предположение ветви) при попытке выйти из
   цикла. Это может быть болезненно на процессорах с глубоким конвейером и привести к целому вороху out-of-order
   (внеочередные исполнения) спекуляций машины. Как правило, вы не хотите, чтобы этот кусок кода приводил к потерям
   скорости. В связи с выше сказанным, когда CAS начинает часто терпеть неудачу, ветвь начинает прогнозировать, что
   управление остается в цикле и в свою очередь, цикл работает быстрее за счет удачного предсказания. Как правило, мы
   хотим некоторого back-off в цикле. И при легкой нагрузке с нечастыми неудачами branch mispredict служит в качестве
   потенциального неявного back-off. Но при более высокой нагрузке мы теряем преимущество back-off, вытекающих из branch
   mispredict. У FAA нет циклов и никаких проблем.