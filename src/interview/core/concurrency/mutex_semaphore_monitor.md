# Mutex, Semaphore, Monitor
## Оглавление
- [Mutex](#mutex)
- [Monitor](#monitor)
- [Semaphore](#semaphore)
- [Mutex vs Semaphore](#mutex-vs-semaphore)
## Mutex
Мьютекс - специальный объект для синхронизации потоков, который "прикреплён" к каждому объекту. У всех объектов всех 
классов есть мьютекс. Название мьютекс от английского MUTal EXclusion - взаимное исключение - отлично отражает его 
назначение. 

Задача мьютекса - обеспечить такой механизм, чтобы доступ к объекту в определённое время был только у одного
потока.

Примером может послужить кассовый кабинет в банке. Кабинет выполняет роль объекта, доступ к которому получают 
несколько потоков. Как только человек (поток) заходит в кабинет, он закрывает дверь. Дверь и выполняет мьютекса, 
запрещая другим людям заходить в кабинет, пока внутри обслуживается человек.

У мьютекса есть несколько важных особенностей:
1) возможны только 2 состояния - свободен и занят
2) состояниями нельзя управлять напрямую, не существует механизмов, которые позволили бы явно взять объект, получить
его мьютекс и присвоить нужный статус
## Monitor
Монитор - это дополнительная "надстройка" мьютексом. Фактически монитор - это "невидимый" для программиста кусок кода. 

Говоря о мьютексе можно привести простой пример:
```java
public class Main {
    private Object obj = new Object();
    
    public void doSomething() {
        // ... какая-то логика для всех потоков
        synchronized (obj) {
            // ... какая-то логика, которая одновременно доступна только для одного потока
        }
    }
}
```
В блоке synchronized происходит захват мьютекса объекта obj. Происходит захват, но как именно обеспечивается защитный 
механизм? Защитный механизм создаёт именно монитор. Компилятор преобразует слово synchronized в несколько специальных 
кусков кода. 

Было:
```java
public class Main {
    private Object obj = new Object();
    
    public void doSomething() {
        // ... какая-то логика для всех потоков
        synchronized (obj) {
            // ... какая-то логика, которая одновременно доступна только для одного потока
            obj.someImportantMethod();
        }
    }
}
```
Стало: 
```java
public class Main {
    private Object obj = new Object();
    
    public void doSomething() {
        // ... какая-то логика для всех потоков
        
        // ... какая-то логика, которая одновременно доступна только для одного потока
        while (obj.getMutex().isBusy()) {
            // пока мьютекс занят, любой другой поток (кроме того, который его захватил) спит
            Thread.sleep(1);
        }
        
        // пометить мьютекс объекта как занятый
        obj.getMutex().isBusy() = true;
        
        obj.someImportantMethod();
        
        // освободить мьютекс объекта
        obj.getMutex().isBusy() = false;
    }
}
```
Пример, конечно, ненастоящий. Здесь мы с помощью Java-подобного кода попытались отразить то, что происходит в этот 
момент внутри Java-машины. Однако этот псевдокод дает отличное понимание того, что на самом деле происходит с объектом 
и потоками внутри блока synchronized и как компилятор преобразует это слово в несколько «невидимых» для
программиста команд.

По сути, монитор в Java выражен с помощью слова synchronized. Весь код, который появился вместо слова synchronized в 
последнем примере, — это и есть монитор.
## Semaphore
Семафор - это средство для синхронизации доступа к какому-то ресурсу.

Его особенность заключается в том, что при создании механизма синхронизации он использует счётчик. Счётчик указывает 
нам, сколько потоков одновременно могут получать доступ к общему ресурсу. 

Семафоры представлены классом Semaphore. При создании семафоров, мы можем использовать такие конструкторы:
```java
Semaphore(int permits);
Semaphore(int permits, boolean fair);
```
В конструктор передаём: 
- int permits - начальное и максимальное значение счётчика. То есть тоЮ сколько потоков могут иметь доступ к общему 
ресурсу.
- boolean fair - для установления порядка, в котором потоки будут получать доступ. Если fair = true, доступ 
предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. Если же он равен false, порядок будет 
определять планировщик потоков.

Классический пример использования семафоров - задача об обедающих философах. Представим, что у нас есть 5 философов, 
которым нужно пообедать. При этом у нас есть один стол, и одновременно находиться за ним могут не более двух человек. 
Наша задача - заблокировать друг друга при попытке сесть за стол (мы должны избежать deadlock). 

Таким образом выглядит класс философа:
```java
class Philosopher extends Thread {
    // поел ли философ
    private boolean full = false;
   private Semaphore sem;
   private String name;

   Philosopher(Semaphore sem, String name) {
       this.sem=sem;
       this.name=name;
   }

   public void run()
   {
       try
       {
           // если философ еще не ел
           if (!full) {
               //Запрашиваем у семафора разрешение на выполнение
               sem.acquire();
               System.out.println (name + " садится за стол");

               // философ ест
               sleep(300);
               full = true;

               System.out.println (name + " поел! Он выходит из-за стола");
               sem.release();

               // философ ушел, освободив место другим
               sleep(300);
           }
       }
       catch(InterruptedException e) {
           System.out.println ("Что-то пошло не так!");
       }
   }
}
```
А вот код для запуска программы:
```java
public class Main {
   public static void main(String[] args) {
       Semaphore sem = new Semaphore(2);
       new Philosopher(sem,"Сократ").start();
       new Philosopher(sem,"Платон").start();
       new Philosopher(sem,"Аристотель").start();
       new Philosopher(sem,"Фалес").start();
       new Philosopher(sem,"Пифагор").start();
   }
}
```
То есть мы как бы добавили официанта, который разрешает есть лишь нескольким философам, а не всем вместе.

Мы создали семафор со счетчиком 2, чтобы соответствовать условию: одновременно есть могут только два философа. То есть, 
одновременно работать могут только два потока, ведь наш класс Philosopher унаследован от Thread!

Методы acquire() и release() класса Semaphore управляют его счетчиком разрешений. Метод acquire() запрашивает 
разрешение на доступ к ресурсу у семафора. Если счетчик > 0, разрешение предоставляется, а счетчик уменьшается на 1.

Метод release() «освобождает» выданное ранее разрешение и возвращает его в счетчик (увеличивает счетчик разрешений 
семафора на 1).

Вот какой вывод в консоль мы получили:
```
Сократ садится за стол
Платон садится за стол
Сократ поел! Он выходит из-за стола
Платон поел! Он выходит из-за стола
Аристотель садится за стол
Пифагор садится за стол
Аристотель поел! Он выходит из-за стола
Пифагор поел! Он выходит из-за стола
Фалес садится за стол
Фалес поел! Он выходит из-за стола
```
У нас все получилось! И хотя Фалесу пришлось обедать в одиночку, думаю, он на нас не в обиде :)
## Mutex vs Semaphore
Мьютекс и семафор имеют одинаковое предназначение: синхронизировать доступ к какому-то ресурсу. Разница только в том, 
что мьютекс объекта может захватить одновременно только один поток, а в случае с семафором используется счётчик потоков, 
и доступ к ресурсу могут получить сразу несколько из них. И это не просто случайное сходство.

На самом деле мьютекс - это одноместный семафор. То есть, это семафор, счётчик которого изначально установлен в 
значении 1. Его ещё называют "двоичным семафором", поскольку его счётчик может иметь только 2 значения - 1 ("свободно")
и 0 ("занято").
