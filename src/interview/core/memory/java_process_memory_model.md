# Введение в Java Process Memory Model
## Оглавление
- [Память Java процесса](#память-java-процесса)
- [Metaspace](#metaspace)
- [Управление Metaspace](#управление-metaspace)
- [Heap и Stack](#heap-и-stack)
- [Heap](#heap)
- [Eden](#eden)
- [S0 и S1 - Survival](#s0-и-s1---survival)
- [Old Gen](#old-gen)
- [Управление Heap](#управление-heap)
- [Stack](#stack)
- [Типы ссылок](#типы-ссылок)
- [Сильная ссылка](#сильная-ссылка)
- [Слабая ссылка](#слабая-ссылка)
- [Мягкая ссылка](#мягкая-ссылка)
- [Фантомная ссылка](#фантомная-ссылка)
- [Процесс сборки мусора](#процесс-сборки-мусора)
## Память Java процесса
Память, выделяемая Java процессу, представляет из себя набор из двух областей:
- PermGen(до Java 8)/Metaspace (заменил PermGen, начиная с Java 8)
- Heap
- Stack
## Metaspace
Metaspace - это область памяти в которой хранится статическая инфорация Java приложения, такая как метаданные 
загруженных классов. По умолчанию, metaspace увеличивается автоматически и не имеет явного ограничения. Без
установленного ограничения размер metaspace неявно ограничен объёмом системной памяти хоста.
## Управление Metaspace
Управлять metaspace областью можно с помощью следующих флагов JVM:
- -XX:MetaspaceSize - минимальный объём памяти для области
- -XX:MaxMetaspaceSize - максимальный объём памяти для области
- -XX:MinMetaspaceFreeRatio - минимально зарезервированный размер памяти после очистки GC (в процентах)
- -XX:MaxMetaspaceFreeRatio - максимально зарезервированный размер памяти после очистки GC (в процентах)
## Heap и Stack
![структура памяти](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d15/8b9/3a2/d158b93a2c0cab7278c518e9121ad314.jpeg)
## Heap
Heap - это область памяти в которой хранятся инстансы объектов. Каждый раз, когда разработчик создаёт инстанс 
какого-либо класса с помощью операции new(пример: new Object()), память под объект выделяется именно в heap'е.

Строковый пул, так же, начиная с Java 7 располагается в heap'е.

Heap, в свою очередь, содержит несколько подобластей, каждая из которых выполняет свою определённую роль. Поговорим о 
них подробнее. Следующие подобласти относятся к heap'у:
- Eden
- Survival (S0 & S1)
- Old Gen

![сегменты heap](https://habrastorage.org/r/w1560/getpro/habr/upload_files/07c/af1/7d9/07caf17d9f5dc880240ee403a90c1c95.png)
## Eden
Это сегмент heap области в который свежесозданные объекты попадают в первую очередь. Каждый раз, когда в Java приложении 
выполняется инструкция new, память, выделяемая под новый инстанс, выделяется именно в Eden сегменте.

Для этого правила есть исключения - если размер памяти, необходимый для хранения инстанса достаточно большой, то JVM 
может выделить память под него сразу в Old Gen сегменте.

Надолго свежесозданные объекты в Eden сегменте не задержатся. После первого же запуска процесса сборки мусора, они либо 
будут удалены из памяти, либо будут перенесены в Survival сегменты heap'а.
## S0 и S1 - Survival
Survival сегмент области heap'а используется JVM для хранения объектов, которые пережили один и более проходов сборщика 
мусора.

Survival сегмент представлен в JVM двумя сегментами - S0 и S1. Они служат неким "перевалочным пунктом" для объектов на 
пути к Old Gen сегменту. В S0 и S1 сегментах объекты могут провести какое-то время до тех пор, пока они не будут удалены 
из памяти или переведены в Old Gen сегмент.

Если быть точным, то в JVM есть настройка, позволяющая указать количество запусков сборки мусора, которое объект должен 
пережить, для того, чтобы попасть в Old Gen сегмент. По умолчанию, это количество равно 15.

Почему Survival область представлена двумя сегментами S0 и S1? Всё дело в том, что для ускорения очистки памяти и
исправления её фрагментации, в ходе процесса сборки мусора два этих сегмента дефрагминтируются и меняются местами.
## Old Gen
Old Gen сегмент heap'а используется для хранения объектов, которые пережили установленное количество запусков 
сборки мусора.

Полная схема памяти Java процесса выглядит следующим образом:

![Полная схема памяти Java процесса](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4e6/992/880/4e6992880fd0cea086036887a38472ca.png)
## Управление Heap
Управлять heap областью можно с помощью следующих флагов JVM:
- -Xms - минимальный объём памяти всей области
- -Xmx - максимальный объём памяти всей области 
- -XX:NewSize - минимальный объём памяти Eden сегмента 
- -XX:MaxNewSize - максималный объём памяти Eden сегмента 
- -XX:SurvivorRatio - соотношение между объёмами памяти Eden и Survival сегментов
## Stack
Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов значений (также известных в Java как 
примитивные типы), которые содержат само значение, а не ссылку на объект из кучи.

Кроме того, переменные в стеке имеют определенную видимость, также называемую областью видимости. Используются только 
объекты из активной области. Например, предполагая, что у нас нет никаких глобальных переменных (полей) области 
видимости, а только локальные переменные, если компилятор выполняет тело метода, он может получить доступ только к 
объектам из стека, которые находятся внутри тела метода. Он не может получить доступ к другим локальным переменным, 
так как они не входят в область видимости. Когда метод завершается и возвращается, верхняя часть стека выталкивается, 
и активная область видимости изменяется.

Возможно, вы заметили, что на картинке выше отображено несколько стеков памяти. Это связано с тем, что стековая память 
в Java выделяется для каждого потока. Следовательно, каждый раз, когда поток создается и запускается, он имеет свою 
собственную стековую память и не может получить доступ к стековой памяти другого потока.
## Типы ссылок
Разница между типами ссылок заключается в том, что объекты в куче, на которые они ссылаются, имеют право на сборку 
мусора по различным критериям. Рассмотрим подробнее каждую из них.
## Сильная ссылка
Это самые популярные ссылочные типы, к которым мы все привыкли. 
```java
// Пример сильной ссылки:
StringBuilder sb = new StringBuilder();
```
Объект в куче не удаляется сборщиком мусора, пока на 
него указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок.
## Слабая ссылка
Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки мусора. 
Слабая ссылка создается следующим образом:
```java
WeakReference<StringBuilder> reference = new WeakReference<>(new StringBuilder());
```
Хорошим вариантом использования слабых ссылок являются сценарии кеширования. Представьте, что вы извлекаете некоторые 
данные и хотите, чтобы они также были сохранены в памяти - те же данные могут быть запрошены снова. С другой стороны, 
вы не уверены, когда и будут ли эти данные запрашиваться снова. Таким образом, вы можете сохранить слабую ссылку на 
него, и в случае запуска сборщика мусора, возможно, он уничтожит ваш объект в куче. Следовательно, через некоторое 
время, если вы захотите получить объект, на который вы ссылаетесь, вы можете внезапно получить null значение. Хорошей 
реализацией сценариев кеширования является коллекция WeakHashMap <K, V>. Если мы откроем WeakHashMap класс в Java API, 
мы увидим, что его записи фактически расширяют WeakReferenceкласс и используют его поле ref в качестве ключа 
отображения (Map):
```java
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> { 
    V value;
}
```
После сбора мусора ключа из WeakHashMap вся запись удаляется из карты.
## Мягкая ссылка
Эти типы ссылок используются для более чувствительных к памяти сценариев, поскольку они будут собираться сборщиком 
мусора только тогда, когда вашему приложению не хватает памяти. Следовательно, пока нет критической необходимости в
освобождении некоторого места, сборщик мусора не будет касаться легко доступных объектов. Java гарантирует, что все 
объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В
документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые объекты гарантированно очищены до того, 
как виртуальная машина выдаст OutOfMemoryError».

Подобно слабым ссылкам, мягкая ссылка создается следующим образом:
```java
SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
```
## Фантомная ссылка
Используется для планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы. 
Используется только с очередью ссылок, поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы 
ссылок считаются предпочтительными для финализаторов.
## Процесс сборки мусора
Как обсуждалось ранее, в зависимости от типа ссылки, которую переменная из стека содержит на объект из кучи, в
определенный момент времени этот объект становится подходящим для сборщика мусора.
![объекты, подходящие для сборки мусора](https://habrastorage.org/r/w1560/getpro/habr/upload_files/42c/277/72f/42c27772f2dfc09c60be6662bc724bee.jpeg)
Например, все объекты, отмеченные красным цветом, могут быть собраны сборщиком мусора. Вы можете заметить, что в куче 
есть объект, который имеет строгие ссылки на другие объекты, которые также находятся в куче (например, это может быть 
список, который имеет ссылки на его элементы, или объект, имеющий два поля типа, на которые есть ссылки). Однако, 
поскольку ссылка из стека потеряна, к ней больше нельзя получить доступ, так что это тоже мусор.

Чтобы углубиться в детали, давайте сначала упомянем несколько вещей:
- Этот процесс запускается автоматически Java, и Java решает, запускать или нет этот процесс. 
- На самом деле это дорогостоящий процесс. При запуске сборщика мусора все потоки в вашем приложении приостанавливаются
(в зависимости от типа GC, который будет обсуждаться позже). 
- На самом деле это более сложный процесс, чем просто сбор мусора и освобождение памяти.

Несмотря на то, что Java решает, когда запускать сборщик мусора, вы можете явно вызвать System.gc()и ожидать, что
сборщик мусора будет запускаться при выполнении этой строки кода, верно?

Это ошибочное предположение.

Вы только как бы просите Java запустить сборщик мусора, но, опять же, Java решать, делать это или нет. В любом случае 
явно вызывать System.gc()не рекомендуется.

Поскольку это довольно сложный процесс и может повлиять на вашу производительность, он реализован разумно. Для этого
используется так называемый процесс «Mark and Sweep». Java анализирует переменные из стека и «отмечает» все объекты, 
которые необходимо поддерживать в рабочем состоянии. Затем все неиспользуемые объекты очищаются.

Так что на самом деле Java не собирает мусор. Фактически, чем больше мусора и чем меньше объектов помечены как живые, 
тем быстрее идет процесс. Чтобы сделать это еще более оптимизированным, память кучи на самом деле состоит из нескольких
частей. Мы можем визуализировать использование памяти и другие полезные вещи с помощью JVisualVM, инструмента, 
поставляемого с Java JDK. Единственное, что вам нужно сделать, это установить плагин с именем Visual GC, который 
позволяет увидеть, как на самом деле структурирована память. Давайте немного увеличим масштаб и разберем общую картину:

![поколения памяти кучи](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a9f/ad0/1b7/a9fad01b762bf7083f3d8102914ed810.jpeg)

Когда объект создается, он размещается в пространстве Eden (1). Поскольку пространство Eden не такое уж большое, оно 
заполняется довольно быстро. Сборщик мусора работает в пространстве Eden и помечает объекты как живые.

Если объект выживает в процессе сборки мусора, он перемещается в так называемое пространство выжившего S0(2). Во второй 
раз, когда сборщик мусора запускается в пространстве Eden, он перемещает все уцелевшие объекты в пространство S1(3). 
Кроме того, все, что в настоящее время находится на S0(2), перемещается в пространство S1(3).

Если объект выживает в течение X раундов сборки мусора (X зависит от реализации JVM, в моем случае это 8), скорее всего,
он выживет вечно и перемещается в пространство Old(4).

Принимая все сказанное выше, если вы посмотрите на график сборщика мусора (6), каждый раз, когда он запускается, вы 
можете увидеть, что объекты переключаются на пространство выживших и что пространство Эдема увеличивалось. И так далее.
Старое поколение также может быть обработано сборщиком мусора, но, поскольку это большая часть памяти по сравнению с 
пространством Eden, это происходит не так часто. Metaspace (5) используется для хранения метаданных о ваших 
загруженных классах в JVM.
