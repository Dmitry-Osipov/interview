# Сборка мусора
## Оглавление
- [Сборка мусора: введение](#сборка-мусора-введение)
- [Сборка мусора: процесс](#сборка-мусора-процесс)
- [Поколения объектов](#поколения-объектов)
- [Сборка мусора: флаги](#сборка-мусора-флаги)
- [Типы сборщиков мусора](#типы-сборщиков-мусора)
- [Инструменты мониторинга GC](#инструменты-мониторинга-gc)
## Сборка мусора: введение
Мусором считается объект, который больше не может быть достигнут по ссылке из какого-либо объекта. Поскольку такие 
объекты больше не используются в приложении, то их можно удалить из памяти.

Например, на диаграмме ниже объект fruit2 может быть удален из памяти, поскольку на него нет ссылок.

![мусор](https://habrastorage.org/r/w1560/getpro/habr/upload_files/309/ca4/273/309ca427316a70c5e5f423d8e1514a42.png)

Сборка мусора — это процесс автоматического управления памятью. Освобождение памяти (путем очистки мусора) выполняется 
автоматически специальным компонентом JVM — сборщиком мусора (Garbage Collector, GC). 

![HotSpot JVM: Architecture](https://habrastorage.org/r/w1560/getpro/habr/upload_files/92f/474/57b/92f47457bbde89cf5a58c156d170927a.png)
## Сборка мусора: процесс
Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:
- Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). 
На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World".
- Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
- Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый непрерывный блок памяти. Это уменьшает 
фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

![Mark & Sweep GC](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8f7/f4a/25f/8f7f4a25f345824f3b18b93d491aced9.png)
## Поколения объектов
Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в 
зависимости от их возраста (как долго они используются в приложении).

- Young Generation (молодое поколение). Здесь создаются новые объекты. Область young generation разделена на три части 
раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).
- Old Generation (старое поколение). Здесь хранятся давно живущие объекты.

![Поколения в куче](https://habrastorage.org/r/w1560/getpro/habr/upload_files/630/451/753/630451753794dc679fbacb89ce108691.png)

Когда запускается этап mark, работа приложения останавливается. После завершения mark приложение возобновляет свою 
работу. Любая сборка мусора — это "Stop the World".

Как уже упоминалось ранее, для оптимизации этапов mark и sweep используются поколения. Гипотеза о поколениях говорит о 
следующем:
- Большинство объектов живут недолго. 
- Если объект выживает, то он, скорее всего, будет жить вечно. 
- Этапы mark и sweep занимают меньше времени при большом количестве мусора. То есть маркировка будет происходить 
быстрее, если анализируемая область небольшая и в ней много мертвых объектов.

Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:

![Сборка мусора поколениями](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d8b/a3f/a48/d8ba3fa48616085ab2b5d79dfde43d71.png)

- Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые. 
- Когда область Eden заполняется, происходит минорная сборка мусора (Minor GC). Minor GC — это процесс, при котором 
операции mark и sweep выполняются для young generation (молодого поколения). 
- После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью
удаляются. 
- По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young 
generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается
(отметка о том, что они пережили сборку мусора). 
- При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты
перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются. 
- Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество
Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old. 
- Major GC. При Major GC этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с
Minor GC, поскольку старое поколение в основном состоит из живых объектов.

Преимущества использования поколений: Minor GC происходит в меньшей части кучи (~ 2/3 от кучи). Этап маркировки 
эффективен, потому что область небольшая и состоит в основном из мертвых объектов.

Недостатки использования поколений: В каждый момент времени одно из пространств Survivor (S0 или S1) пустое и не 
используется.
## Сборка мусора: флаги
| Флаг                         | Описание                                                                                 |
|------------------------------|------------------------------------------------------------------------------------------|
| -Xms                         | Первоначальный размер кучи                                                               |
| -Xmx                         | Максимальный размер кучи                                                                 |
| -XX:NewRatio=n               | Отношение размера Old Generation к Young Generation                                      |
| -XX:SurvivorRatio=n          | Отношение размера Eden к Survivor                                                        |
| -XX: MaxTenuringThreshold=n  | Возраст объекта, когда объект перемещается из области Survivor в область Old Generation  |
## Типы сборщиков мусора
| Сборщик мусора | Описание                                                            | Преимущества                                                                                                                    | Когда использовать                                                                                                                                                                                                            | Флаги для включения |
|----------------|---------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------|
| Serial         | Использует один поток                                               | Эффективный, т.к. нет накладных расходов на взаимодействие потоков                                                              | Однопроцессорные машины. <br/> Работа с небольшими наборами данных                                                                                                                                                            | -XX:+UseSerialGC    |
| Parallel       | Использует несколько потоков                                        | Многопоточность ускоряет сборку мусора                                                                                          | В приоритете пиковая производительность. <br/> Допустимы паузы в 1 секунду и более. <br/> Работа со средними и большими наборами данных. <br/> Для приложений, работающих на многопроцессорном или многопоточном оборудовании | -XX:+UseParallelGC  |
| G1             | Выполняет некоторую тяжёлую работу параллельно с работой приложения | Может использоваться как на небольших системах, так и на больших с большим количеством процессоров и большим количеством памяти | Когда время отклика важнее пропускной способности. <br/> Паузы GC должны быть меньше 1 секунды                                                                                                                                | -XX:+UseG1GC        |
| Z1             | Выполняет всю тяжёлую работу параллельно с работой приложения       | Низкая задержка                                                                                                                 | В приоритете время отклика                                                                                                                                                                                                    | -XX:+UseZGC         |
## Инструменты мониторинга GC
Что стоит мониторить:
- Частота запуска сборки мусора. Так как GC вызывает "stop the world", поэтому чем время сборки мусора меньше, тем лучше 
- Длительность одного цикла сборки мусора

Как мониторить GC:
- Visual VM 
- Для включения логирования событий сборщика мусора добавьте следующие параметры JVM:
```
-XX:+PrintGCDateStamps -verbose:gc -XX:+PrintGCDetails -
Xloggc:/tmp/[Application-Name]-[Application-port]-%t-gc.log -
XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=20 -
XX:GCLogFileSize=100M
```
Логи GC выглядят следующим образом:
```
[15,651s][info ][gc] GC(36) Pause Young (G1 Evacuation Pause) 239M->57M(307M) (15,646s, 15,651s) 5,048ms
```
Объяснение:
```
[Время старта приложения = 15,651s]

[Уровень сообщения = info]

[Тег = gc]

[Тип GC = Pause Young] 

[Причина запуска GC = G1 Evacuation Pause] 

[Информация о потреблении памяти : "занято до GC" = 239M -> "занято после GC" = 57M (Размер кучи = 307M)] 

[Время начала и окончания GC = 15,646s, 15,651s] 

[Общее время GC = 5,048ms]
```
Логи GC удобно анализировать с помощью gcEasy.io
