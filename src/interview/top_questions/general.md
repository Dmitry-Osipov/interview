# Вопросы с собеседований
## Оглавление
- [Есть 1 задача, которая должна быть асинхронно выполнена, но у нас есть 2 пода](#есть-1-задача-которая-должна-быть-асинхронно-выполнена-но-у-нас-есть-2-пода)
- [Когда делать фильтрацию на стороне БД, а когда с помощью Stream API](#когда-делать-фильтрацию-на-стороне-бд-а-когда-с-помощью-stream-api)
## Есть 1 задача, которая должна быть асинхронно выполнена, но у нас есть 2 пода
### Использование взаимных блокировок (locking) на уровне БД
Самый надёжный способ — синхронизация через централизованную систему, такую как база данных. Один из вариантов — 
использовать блокировки на уровне базы данных, чтобы гарантировать, что только один под выполнит задачу в указанный 
момент времени.

Пример:
- Redis: Redis предоставляет механизмы блокировки, которые можно использовать для синхронизации выполнения задач. В 
этой схеме задача проверяет наличие блокировки перед выполнением. Если блокировка активна, задача не выполняется. Если 
нет, под берёт блокировку и выполняет задачу.
  - Алгоритм:
    1) Оба пода в определённое время пытаются установить блокировку в Redis (например, с помощью команды SETNX, которая
ставит значение только если оно ещё не существует)
    2) Только один под успешно установит блокировку
    3) Под, который установил блокировку, отправляет сообщение на почту
    4) После выполнения задачи блокировка снимается
```java
public void sendEmail() {
    boolean lockAcquired = redisTemplate.opsForValue().setIfAbsent("emailTaskLock", "lock", 10, TimeUnit.MINUTES);
    if (lockAcquired) {
        // Под установил блокировку и выполняет задачу
        try {
            emailService.sendEmail();
        } finally {
            redisTemplate.delete("emailTaskLock");
        }
    } else {
        // Другой под уже выполняет задачу, текущий под пропускает выполнение
    }
}
```
- PostgreSQL: Используя механизм advisory locks в PostgreSQL, можно также решить эту задачу.
```sql
SELECT pg_try_advisory_lock(123456);  -- Уникальный идентификатор блокировки
-- Один из подов успешно возьмёт блокировку и выполнит задачу. После завершения блокировка снимается с помощью:
SELECT pg_advisory_unlock(123456);
```
### Использование leader election (выбор лидера)
Kubernetes предоставляет механизм "выбора лидера" для подов с помощью сторонних библиотек или сервисов, например, 
Spring Cloud Kubernetes или Kubernetes Leader Election.

Spring Cloud Kubernetes предоставляет решение для автоматической выборки "лидера" среди подов. Лидер отвечает за 
выполнение задачи, а остальные поды "следят" за ним. Если текущий лидер по каким-то причинам "падает", другой под
становится лидером и продолжает выполнение задачи. Пример:
1) Добавляем зависимость в pom.xml:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-leader</artifactId>
</dependency>
```
2) Настраиваем лидера в application.yaml:
```yaml
spring:
  cloud:
    kubernetes:
      leader:
        enabled: true
        namespace: default
        role: scheduler
```
3) В коде задачи проверяем, является ли под лидером:
```java
@Scheduled(cron = "0 0 15 15 * ?")
public void sendEmailIfLeader() {
    if (leadershipController.isLeader()) {
        emailService.sendEmail();
    }
}
```
В этом случае только лидер будет отправлять письмо. Если текущий лидер перестанет быть доступен, другой под возьмёт на
себя роль лидера и продолжит выполнение задач.
### Использование внешнего планировщика
Вместо того, чтобы настраивать @Scheduled внутри приложения, можно использовать Kubernetes CronJob, который сам будет
гарантировать выполнение задачи только один раз в нужное время.
```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: send-email-job
spec:
  schedule: "0 15 15 * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: send-email
            image: my-email-sender-image
          restartPolicy: OnFailure
```
Kubernetes CronJob создаст один под, который выполнит задачу в нужное время, таким образом исключая дублирование задачи.
## Когда делать фильтрацию на стороне БД, а когда с помощью Stream API
### Когда использовать БД
1) Большие объёмы данных:

Когда в базе данных хранится много записей, имеет смысл фильтровать данные непосредственно в запросе, чтобы 
минимизировать количество данных, передаваемых по сети. Это уменьшит нагрузку на сеть и сервер приложения:
```sql
SELECT * FROM orders WHERE status = 'PENDING';
```
2) Использование индексов:

Если фильтруемые поля индексированы, база данных может воспользоваться этими индексами, чтобы выполнить фильтрацию 
намного быстрее, чем если бы те же данные были переданы приложению. Пример: Если на колонку status в таблице orders 
создан индекс, то запрос вида:
```sql
SELECT * FROM orders WHERE status = 'PENDING';
```
будет выполнен быстрее, так как база данных использует индекс для оптимизации поиска.
3) Экономия ресурсов сервера приложения:

Когда фильтрация выполняется на стороне базы данных, нагрузка на сервер приложения уменьшается, так как приложение 
получает уже отфильтрованные данные. Это особенно важно для приложений, работающих с ограниченными ресурсами.
4) Сложные фильтры и агрегации:

Базы данных лучше справляются с более сложными операциями фильтрации, такими как джоины, агрегации, группировки и 
подзапросы:
```sql
SELECT department, COUNT(*) 
FROM employees 
WHERE salary > 5000 
GROUP BY department;
```
5) Снижение сетевой нагрузки:

Фильтрация на уровне БД значительно сокращает объём передаваемых данных. Это важно в случаях, когда приложение работает
удалённо от базы данных или когда соединение с базой данных имеет ограниченную пропускную способность.
### Когда использовать Stream API
1) Небольшие объёмы данных:

Если объём данных небольшой и передача их на сервер приложения не создаёт проблем с производительностью или сетью, 
можно использовать Stream API для фильтрации. Это даёт больше гибкости для дальнейшей обработки данных на уровне 
приложения:
```java
List<Order> filteredOrders = orders.stream()
                                   .filter(order -> order.getStatus().equals("PENDING"))
                                   .collect(Collectors.toList());
```
2) Сложная бизнес-логика:

Когда фильтрация требует сложной логики, которую сложно или неудобно реализовать на уровне SQL-запроса, удобнее
выполнять её на уровне приложения. В Stream API ты можешь использовать методы, коллекторы и лямбда-выражения для гибкой
настройки фильтрации:
```java
List<Order> filteredOrders = orders.stream()
        .filter(order -> order.getStatus().equals("PENDING") && order.getTotal() > 1000)
        .collect(Collectors.toList());
```
3) Необходимость динамической фильтрации:

Если нужно динамически изменять условия фильтрации на основе пользовательского ввода или других параметров в приложении, 
использование Stream API предоставляет гибкость для таких изменений без необходимости пересоздания SQL-запросов:
```java
Predicate<Order> filterCondition = order -> order.getTotal() > minTotal;
if (includePending) {
    filterCondition = filterCondition.and(order -> order.getStatus().equals("PENDING"));
}

List<Order> filteredOrders = orders.stream()
    .filter(filterCondition)
    .collect(Collectors.toList());
```
4) Когда данные уже загружены в память:

Если данные уже загружены в память (например, получены из кэша или API), проще и быстрее отфильтровать их с помощью 
Stream API, чем заново выполнять запрос к базе данных.
5) Операции, специфичные для Java:

Если данные нужно фильтровать с учётом особенностей Java (например, работа с типами, вызов методов Java-классов),
фильтрация через Stream API будет более естественной, чем попытки реализовать это через SQL.
