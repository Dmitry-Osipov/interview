# Общая информация о бинах
## Оглавление
- [Жизненный цикл](#жизненный-цикл)
- [Bean Scope](#bean-scope)
- [Как заинжектить prototype в singleton](#как-заинжектить-prototype-в-singleton)
## Жизненный цикл
Жизненный цикл бина в Spring — это процесс, через который проходит объект, управляемый контейнером Spring, от его 
создания до удаления. Этот процесс включает несколько этапов, начиная с создания бина и заканчивая его уничтожением.
#### 1. Создание бина
Контейнер Spring создаёт экземпляр бина с использованием конструктора. Это первый этап жизненного цикла, на котором
происходит инициализация объекта.

Этапы создания:
- Если используется инъекция через конструктор, контейнер сначала вызывает конструктор бина.
- Если используется инъекция через сеттеры, контейнер создаёт пустой экземпляр объекта (через конструктор без 
параметров) и затем вызывает методы-сеттеры для внедрения зависимостей.
#### 2. Заполнение зависимостей (Dependency Injection)
После создания бина контейнер Spring заполняет его зависимости (инъекция зависимостей). Это может включать в себя:
- Инъекцию других бинов (например, через конструкторы, сеттеры или аннотации, такие как @Autowired).
- Установку значений свойств (например, через конфигурационные файлы или аннотации, такие как @Value).
#### 3. Вызов метода Aware интерфейсов (если применимо)
Если бин реализует один или несколько специальных интерфейсов, контейнер Spring вызывает соответствующие методы для 
передачи определенной информации бин:
- BeanNameAware: Передает имя бина.
- BeanFactoryAware: Передает ссылку на BeanFactory, который создал бин.
- ApplicationContextAware: Передает ссылку на текущий контекст приложения.
#### 4. Вызов метода BeanPostProcessor (перед инициализацией)
Контейнер Spring проходит через все зарегистрированные BeanPostProcessor-ы и вызывает их метод 
postProcessBeforeInitialization(). Это позволяет модифицировать бин до его инициализации.
#### 5. Инициализация бина
После выполнения всех предыдущих шагов, происходит инициализация бина. Это может включать:
- Вызов метода afterPropertiesSet() из интерфейса InitializingBean.
- Вызов пользовательского инициализационного метода, указанного через аннотацию @PostConstruct или метод init-method в
конфигурационном файле Spring.
#### 6. Вызов метода BeanPostProcessor (после инициализации)
После инициализации контейнер снова проходит через все зарегистрированные BeanPostProcessor-ы и вызывает их метод 
postProcessAfterInitialization(). Это позволяет модифицировать бин уже после того, как он был инициализирован.
#### 7. Готовность бина к использованию
На этом этапе бин полностью инициализирован и готов к использованию в приложении. Контейнер Spring теперь может 
отдавать его другим бинам, управлять его жизненным циклом и так далее.
#### 8. Закрытие контекста и уничтожение бина
Когда контейнер Spring завершает работу (например, при остановке приложения), происходит уничтожение бинов.
- Сначала вызывается пользовательский метод, отмеченный аннотацией @PreDestroy или указанный в конфигурации через 
destroy-method.
- Затем, если бин реализует интерфейс DisposableBean, вызывается его метод destroy().
#### Особенности 
- Весь процесс управляется контейнером Spring, что позволяет разработчикам сконцентрироваться на бизнес-логике, не 
заботясь о низкоуровневых аспектах управления объектами.
- Внедрение зависимостей и обработка интерфейсов Aware позволяют бинам интегрироваться с контейнером Spring, получать 
нужные зависимости и информацию.
## Bean Scope

В Spring Framework "scope" (область видимости) определяет жизненный цикл и область действия бина — то есть, как долго 
будет существовать объект бина и сколько экземпляров будет создано. Spring поддерживает несколько областей видимости
для бинов.
#### 1. Singleton
- Описание: Это область видимости по умолчанию. В этом режиме контейнер Spring создаёт только один экземпляр бина на 
весь контекст приложения. Этот экземпляр используется каждый раз, когда бин запрашивается.
- Жизненный цикл: Создаётся при инициализации контекста и уничтожается при закрытии контекста.
- Применение: Подходит для бинов, которые могут использоваться в нескольких частях приложения и не содержат состояния, 
связанного с запросом или сессией.
```java
@Component
public class MySingletonBean {
    // Этот бин будет существовать в единственном экземпляре
}
```
#### 2. Prototype
- Описание: В этом режиме контейнер Spring создаёт новый экземпляр бина каждый раз, когда он запрашивается.
- Жизненный цикл: Создаётся при каждом запросе и уничтожается сборщиком мусора Java, когда на него больше не остаётся
ссылок.
- Применение: Используется для объектов, состояние которых может меняться и которые не должны разделяться между другими 
частями приложения.
```java
@Component
@Scope("prototype")
public class MyPrototypeBean {
    // Каждый раз, когда запрашивается этот бин, создается новый экземпляр
}
```
#### 3. Request
- Описание: Специфический для веб-приложений scope. Бин создаётся и действует в рамках одного HTTP-запроса. Для каждого 
запроса создается новый экземпляр бина.
- Жизненный цикл: Создаётся при начале HTTP-запроса и уничтожается, когда запрос завершён.
- Применение: Подходит для бинов, которые должны жить только в рамках одного HTTP-запроса.
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyRequestScopedBean {
    // Этот бин существует только в рамках одного HTTP-запроса
}
```
#### 4. Session
- Описание: Также специфический для веб-приложений scope. Бин создается на время одной HTTP-сессии и существует в 
течение всего времени жизни этой сессии.
- Жизненный цикл: Создаётся при начале HTTP-сессии и уничтожается при завершении сессии.
- Применение: Используется для бинов, которые должны сохранять своё состояние на протяжении всей сессии пользователя.
```java
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MySessionScopedBean {
    // Этот бин существует в течение всей HTTP-сессии
}
```
#### 5. Application
- Описание: Подобно singleton, но область видимости application применяется к ServletContext. Бин с таким scope 
создаётся один раз на весь жизненный цикл веб-приложения, но при этом он может быть доступен всем сервлетам (Сервлет —
это Java-класс, который обрабатывает HTTP-запросы и генерирует HTTP-ответы. Он работает на стороне сервера и является 
основным строительным блоком для создания веб-приложений на Java. Сервлеты используются для динамического создания 
контента (например, HTML-страниц), обработки форм, работы с базами данных, управления сессиями и т.д.) и сервлетным 
фильтрам (Сервлетный фильтр — это Java-класс, который позволяет перехватывать и изменять как входящие HTTP-запросы, так 
и исходящие HTTP-ответы. Фильтры могут использоваться для выполнения задач, таких как аутентификация, логирование, 
сжатие данных, управление кодировками и так далее).
- Жизненный цикл: Создаётся при старте веб-приложения и уничтожается при его завершении.
- Применение: Используется для объектов, которые должны разделяться между всеми компонентами веб-приложения.
```java
@Component
@Scope("application")
public class MyApplicationScopedBean {
    // Этот бин существует на протяжении всего времени работы веб-приложения
}
```
#### 6. WebSocket
- Описание: Специфический для WebSocket-приложений scope. Бин создаётся и существует в рамках одной WebSocket-сессии.
- Жизненный цикл: Создаётся при установлении WebSocket-сессии и уничтожается при её завершении.
- Применение: Используется для управления состоянием в WebSocket-сессиях.
- Примечание: WebSocket — это коммуникационный протокол, предназначенный для установления постоянного, двунаправленного 
соединения между клиентом (например, браузером) и сервером через единственное TCP-соединение. В отличие от 
традиционного HTTP-протокола, который работает по принципу "запрос-ответ", WebSocket позволяет серверу отправлять 
данные клиенту в режиме реального времени без необходимости ожидать нового запроса от клиента. Это делает WebSocket
особенно полезным для приложений, требующих мгновенной передачи данных, таких как чаты, онлайн-игры, обновления
финансовых данных и т.д.
```java
@Component
@Scope("websocket")
public class MyWebSocketScopedBean {
    // Этот бин существует в рамках одной WebSocket-сессии
}
```
#### 7. Кастомные области видимости
Spring также позволяет разработчикам создавать свои собственные кастомные области видимости. Это требует реализации
интерфейса org.springframework.beans.factory.config.Scope и регистрации его в контексте Spring.
#### Примечания
- Singleton scope является наиболее часто используемым, поскольку он обеспечивает хорошую производительность и 
экономию ресурсов.
- Специфичные для веб-приложений области видимости, такие как request, session, и application, полезны при разработке 
веб-приложений, где важно управлять жизненным циклом объектов на основе запросов или сессий.
- При работе с prototype бин-ами, важно учитывать, что контейнер Spring не управляет их уничтожением, поэтому 
разработчики должны быть осторожны с управлением памятью.
## Как заинжектить prototype в singleton?
Инъекция бина с областью видимости prototype в бин с областью видимости singleton — это распространенная задача, 
которая требует особого подхода, поскольку бин с областью видимости prototype создается каждый раз при запросе, тогда 
как бин singleton создается один раз и используется повторно.

Вот несколько способов, как это можно сделать в Spring:
#### 1. Использование "ObjectFactory" или "Provider"
Один из наиболее распространенных способов — это использование ObjectFactory или Provider, которые позволяют получать 
новые экземпляры prototype-бина по запросу.
```java
// ObjectFactory
@Component
public class SingletonBean {

    @Autowired
    private ObjectFactory<PrototypeBean> prototypeBeanFactory;

    public void doSomething() {
        PrototypeBean prototypeBean = prototypeBeanFactory.getObject();
        prototypeBean.someMethod();
    }
}

// Provider
@Component
public class SingletonBean {

    @Autowired
    private Provider<PrototypeBean> prototypeBeanProvider;

    public void doSomething() {
        PrototypeBean prototypeBean = prototypeBeanProvider.get();
        prototypeBean.someMethod();
    }
}
```
#### 2. Использование метода с аннотацией "@Lookup"
Аннотация @Lookup в Spring позволяет создавать абстрактные методы в бине singleton, которые будут возвращать экземпляр 
prototype-бина.
```java
@Component
public class SingletonBean {

    public void doSomething() {
        PrototypeBean prototypeBean = getPrototypeBean();
        prototypeBean.someMethod();
    }

    @Lookup
    protected abstract PrototypeBean getPrototypeBean();
}
```
При вызове метода getPrototypeBean() Spring автоматически создает новый экземпляр prototype-бина.
#### 3. Инъекция через "ApplicationContext"
В этом подходе можно использовать ApplicationContext для получения экземпляра prototype-бина. Это менее
предпочтительный метод, но он также работает.
```java
@Component
public class SingletonBean {

    @Autowired
    private ApplicationContext applicationContext;

    public void doSomething() {
        PrototypeBean prototypeBean = applicationContext.getBean(PrototypeBean.class);
        prototypeBean.someMethod();
    }
}
```
#### 4. Использование "Scope" прокси (Lazy-initialized Proxy)
Ещё один способ заключается в использовании прокси, которые создаются для prototype-бина. Это позволяет Spring создавать 
новый экземпляр каждый раз, когда вы вызываете методы через прокси.
```java
@Component
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class PrototypeBean {
    // код бина
}

@Component
public class SingletonBean {

    private final PrototypeBean prototypeBean;

    @Autowired
    public SingletonBean(PrototypeBean prototypeBean) {
        this.prototypeBean = prototypeBean;
    }

    public void doSomething() {
        prototypeBean.someMethod(); // каждый вызов будет использовать новый экземпляр PrototypeBean
    }
}
```
#### Какой метод выбрать?
- ObjectFactory / Provider: Используется для получения контролируемого доступа к новым экземплярам prototype-бина. 
Хороший баланс между простотой и гибкостью. 
- @Lookup: Удобен и декларативен, особенно если вы не хотите вручную управлять экземплярами. 
- ApplicationContext: Менее предпочтительный способ, потому что он создает зависимость от контекста в вашем коде, 
что может усложнить тестирование и сопровождение. 
- Scope Proxy: Удобен, когда вам нужно всегда использовать новый экземпляр prototype-бина, но он добавляет небольшую 
накладную на производительность из-за использования прокси.
