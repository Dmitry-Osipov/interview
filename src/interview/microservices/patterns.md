# Микросервисная архитектура, её паттерны проектирования и особенности
## Оглавление
- [Микросервисы](#микросервисы)
- [Микросервисы против монолитов](#микросервисы-против-монолитов)
- [Преимущества](#преимущества)
- [Недостатки](#недостатки)
- [Сравнение](#сравнение)
- [Паттерны](#паттерны)
- [Strangler](#strangler)
- [Агрегатор](#агрегатор)
- [Proxy](#proxy)
- [Chained](#chained)
- [Branch](#branch)
- [Shared Data](#shared-data)
- [Asynchronous Messaging](#asynchronous-messaging)
- [Service Registry](#service-registry)
- [Circuit Breaker паттерн](#circuit-breaker-паттерн)
- [API Gateway](#api-gateway)
- [Паттерн Saga](#паттерн-saga)
- [Event Sourcing Pattern](#event-sourcing-pattern)
- [Command Query Responsibility Segregation (CQRS) Pattern](#command-query-responsibility-segregation-cqrs-pattern)
- [Bulkhead Pattern](#bulkhead-pattern)
- [Backends for Frontends (BFF)](#backends-for-frontends-bff)
- [Load Balancing Pattern](#load-balancing-pattern)
- [Retry Pattern](#retry-pattern-корректное-восстановление-после-ошибок)
- [Sidecar Pattern](#sidecar-pattern-модульная-функциональность-для-микросервисов)
## Микросервисы
Архитектурный паттерн, способ или стиль архитектуры, если следовать ему правильно, приведет к созданию программного
приложения, состоящего из нескольких сервисов, вместо одного большого монолита.

Сервисы в этом паттерне легко разрабатывать, тестировать, деплоить и поддерживать по отдельности. Достаточно небольших 
команд, которые отвечают за каждый сервис, что сокращает объем коммуникаций, а также облегчает управление.

Это позволяет командам внедрять различные технологические стеки, модернизировать технологии в существующих сервисах,
масштабировать, а также изменять или деплоить каждый сервис независимо.
## Микросервисы против монолитов
И микросервисы, и монолитные сервисы – это архитектурные паттерны, которые используются при разработке программных 
приложений для обслуживания бизнес-требований. У каждого из них есть свои преимущества, недостатки и проблемы.

С одной стороны, когда монолитные архитектуры служат в качестве крупномасштабной системы, это может усложнить ситуацию. 
Они могут быть громоздкими в работе, когда нужно добавить новые функции, внести изменения или даже удалить некоторые 
ненужные функции.

![Монолит](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e8d/aae/57d/e8daae57dc40ae6070d9f2a01762ebe9.png)

Однако монолитные архитектуры по-прежнему являются хорошим вариантом для приведенных ниже случаев:
- малогабаритные приложения; 
- нет необходимости в обновлении технологии; 
- вам требуется меньше времени для вывода на рынок; 
- команды знакомы с Монолитными подходами.

С другой стороны, архитектура микросервисов не очень хорошо подходит для небольших приложений, требующих единого 
технологического стека, платформы деплоя, доменной зоны и т. д. Но для крупномасштабных приложений пока нет
ничего лучше этой архитектуры.

![Микросервисы](https://habrastorage.org/r/w1560/getpro/habr/upload_files/6ac/2ab/82f/6ac2ab82fafdcffbca7de91c53130daa.png)

Микросервисная архитектура является хорошим вариантом для следующих случаев:
- широкомасштабные приложения; 
- вам необходимо обновление технологии; 
- разные команды работают с разными техническими скилами (языки программирования, фреймворки и другое); 
- если у вас есть различные домены, которые необходимо обработать; 
- И многие другие.
## Преимущества
- Меньшие размеры команды с различными наборами навыков позволяют использовать лучшее из каждого языка и фреймворка.
- Более быстрый и независимый деплой, когда в действие вступает реальное использование непрерывной интеграции и деплоя.
- Тестирование каждой службы является простым и менее трудоемким, поскольку службы специфичны для своего
  хранилища данных.
- Различные технологии могут способствовать созданию комплексного решения. Переход от одной технологии к другой
  также прост.
- Изменение в сервисе не повлияет на всю систему, что обеспечивает высокую надежность.
## Недостатки
- Инфраструктура требует больших затрат, поскольку различные технологии имеют различные методологии тестирования,
  среды для каждого сервиса и деплоя.
- Дебаг может стать громоздким из-за различных логов каждого сервиса и выявления ошибок в реальном сервисе.
- Полиглот микросервисов имеет и побочные эффекты, когда компании необходимо поддерживать ресурсы для каждой
  технологии, используемой для разработки сервисов
## Сравнение
Сравним некоторые характеристики микросервисов и монолитной архитектуры, чтобы лучше понять их.

| Характеристика              | Микросервисы                                                                                                                                                                    | Монолит                                                                                                                                                                                                                                                                                  |
|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Скорость                    | Сравнительно медленнее в <br/> понятиях разработки, поскольку <br/> мелкие сервисы разрабатываются <br/> отдельно.                                                              | Быстрее, когда речь идет о <br/> разработке одного приложения, содержащего <br/> почти все необходимое с самого начала.                                                                                                                                                                  |
| Независимость               | Каждый сервис имеет <br/> собственное хранилище данных и <br/> отвечает за конкретный домен, и <br/> может разрабатываться, изменяться или <br/> деплоиться независимо.         | Благодаря тесному взаимодействию <br/> все приложение деплоится при любом изменении, <br/> поскольку вся бизнес-логика <br/> находится в одном месте.                                                                                                                                    |
| Гибкость                    | Сервисы имеют меньший размер, <br/> что делает их легко <br/> адаптируемыми к новым <br/> технологическим изменениям.                                                           | Используется одна и та же <br/> технология, которую нельзя изменить, <br/> поскольку все приложение было <br/> разработано с ее использованием.                                                                                                                                          |
| Масштабирование             | Легко масштабировать сервисы <br/> без ущерба для других.                                                                                                                       | Приходится масштабировать все <br/> приложение, даже если нужно масштабировать <br/> только одну фичу внутри.                                                                                                                                                                            |
| Надежность                  | Нет необходимости останавливать <br/> приложение, если требуется <br/> внести изменения в сервис.                                                                               | Приходится заново деплоить все приложение, <br/> если что-то требует изменений.                                                                                                                                                                                                          |
| Тестируемость               | Сервисы, специфичные для <br/> конкретного домена, легко тестировать.                                                                                                           | Сложно протестировать всю <br/> систему сразу.                                                                                                                                                                                                                                           |
| Удобство <br/> обслуживания | Отдельные сервисы могут быть <br/> обновлены и изменены в <br/> соответствии с рыночными условиями.                                                                             | Трудно поддерживать при увеличении <br/> размера приложения, поскольку изменения <br/> в одном месте могут иметь регрессивные <br/> последствия для других.                                                                                                                              |
| Команды                     | Можно задействовать несколько <br/> небольших команд с различными <br/> наборами технологических скиллов.                                                                       | Требуется одна большая команда <br/> с почти одинаковыми навыками и пониманием <br/> технологий.                                                                                                                                                                                         |
| Управление                  | Управление различными небольшими командами, <br/> каждая из которых работает над определенной <br/> областью бизнеса, позволяет легко анализировать, <br/> кто за что отвечает. | Управление одной большой командой, <br/> работающей над полным доменом, <br/> требует внутреннего разделения.                                                                                                                                                                            |
| Коммуникация                | Коммуникация медленнее, <br/> но легче.                                                                                                                                         | Есть сложность общения с <br/> руководством по поводу возникающих <br/> проблем.                                                                                                                                                                                                         |
| Инфраструктура              | Экспоненциальная стоимость, <br/> поскольку разные команды с <br/> разными навыками работают с несколькими репозиториями, <br/> средами и пайплайнами.                          | Экономическая эффективность, поскольку <br/> команды работают над одним и тем же репозиторием, <br/> и все команды обладают практически одинаковыми <br/> навыками в области технологий. Таким образом, <br/> нет необходимости в нескольких различных <br/> средах разработки и деплоя. |
## Паттерны
- [Strangler](#strangler)
- [Агрегатор](#агрегатор)
- [Proxy](#proxy)
- [Chained](#chained)
- [Branch](#branch)
- [Shared Data](#shared-data)
- [Asynchronous Messaging](#asynchronous-messaging)
- [Service Registry](#service-registry)
- [Circuit Breaker паттерн](#circuit-breaker-паттерн)
- [API Gateway](#api-gateway)
- [Паттерн Saga](#паттерн-saga)
- [Event Sourcing Pattern](#event-sourcing-pattern)
- [Command Query Responsibility Segregation (CQRS) Pattern](#command-query-responsibility-segregation-cqrs-pattern)
- [Bulkhead Pattern](#bulkhead-pattern)
- [Backends for Frontends (BFF)](#backends-for-frontends-bff)
- [Load Balancing Pattern](#load-balancing-pattern)
- [Retry Pattern](#retry-pattern-корректное-восстановление-после-ошибок)
- [Sidecar Pattern](#sidecar-pattern-модульная-функциональность-для-микросервисов)
## Strangler
Этот паттерн предназначен для постепенного перехода к микросервисной архитектуре от монолитного приложения. Старая 
функциональность заменяется новыми сервисами, и последние используются после завершения работы, в то время как 
первые вытесняются.

Фасадный интерфейс играет важную роль в процессе, когда сервисы, отделившись от монолита, выходят во внешний мир.
Таким образом, клиенты узнают о новых сервисах за фасадом, и это заслоняет старую систему.

![Strangler](https://habrastorage.org/r/w1560/getpro/habr/upload_files/b22/fa1/647/b22fa16479cc579106972d2697b74c19.png)
## Агрегатор
В простейшей форме агрегатор представляет собой обычную веб-страницу, вызывающую множество сервисов для реализации 
функционала, требуемого в приложении. Поскольку все сервисы (Service A, Service B и Service C) предоставляются при 
помощи легковесного REST-механизма, веб-страница может извлечь данные и обработать/отобразить их как нужно. Если
требуется какая-либо обработка, например, применить бизнес-логику к данным, полученным от отдельных сервисов, то для 
этого у вас может быть CDI-компонент, преобразующий данные таким образом, чтобы их можно было вывести на веб-странице.

![Aggregator](https://habrastorage.org/r/w1560/files/094/0e1/d15/0940e1d1593b4254baed594640a051b9.png)

Агрегатор может использоваться и в тех случаях, когда не требуется ничего отображать, а нужен лишь более 
высокоуровневый составной микросервис, который могут потреблять другие сервисы. В данном случае агрегатор просто 
соберет данные от всех отдельных микросервисов, применит к ним бизнес-логику, а далее опубликует микросервис как
конечную точку REST. В таком случае, при необходимости, его смогут потреблять другие нуждающиеся в нем сервисы.

Этот паттерн следует принципу DRY. Если существует множество сервисов, которые должны обращаться к сервисам A, B и C, 
то рекомендуется абстрагировать эту логику в составной микросервис и агрегировать ее в виде отдельного сервиса. 
Преимущество абстрагирования на этом уровне заключается в том, что отдельные сервисы, скажем, A, B и C, могут 
развиваться независимо, а бизнес-логику будет по-прежнему выполнять составной микросервис.

Обратите внимание: каждый отдельный микросервис (опционально) имеет собственные уровни кэширования и базы данных. 
Если агрегатор – это составной микросервис, то и у него могут быть такие уровни.

Агрегатор также может независимо масштабироваться как по горизонтали, так и по вертикали. То есть, если речь идет о
веб-странице, то к ней можно прикрутить дополнительные веб-серверы, а если это составной микросервис, использующий 
Java EE, то к нему прикручиваются дополнительные экземпляры WildFly, позволяющие удовлетворить растущие потребности.
## Proxy
Паттерн «посредник» при работе с микросервисами – это вариант агрегатора. В таком случае агрегация должна происходить 
на клиенте, но в зависимости от бизнес-требований при этом может вызываться дополнительный микросервис.

![Proxy](https://habrastorage.org/r/w1560/files/a5e/699/6d1/a5e6996d11e544ea8ebf48f6cddfe906.png)

Как и агрегатор, посредник может независимо масштабироваться по горизонтали и по вертикали. Это может понадобиться в 
ситуации, когда каждый отдельный сервис нужно не предоставлять потребителю, а запускать через интерфейс.

Посредник может быть формальным (dumb), в таком случае он просто делегирует запрос одному из сервисов. Он может быть 
и интеллектуальным (smart), в таком случае данные перед отправкой клиенту подвергаются тем или иным преобразованиям.
Например, уровень представления для различных устройств может быть инкапсулирован в интеллектуальный посредник.
## Chained
Микросервисный паттерн проектирования «Цепочка» выдает единый консолидированный ответ на запрос. В данном случае 
сервис A получает запрос от клиента, связывается с сервисом B, который, в свою очередь, может связаться с сервисом C.
Все эти сервисы, скорее всего, будут обмениваться синхронными сообщениями «запрос/отклик» по протоколу HTTP.

![Chained](https://habrastorage.org/r/w1560/files/876/605/0f5/8766050f52f84c328a48201c495b94e3.png)

Здесь важнее всего запомнить, что клиент блокируется до тех пор, пока не выполнится вся коммуникационная цепочка 
запросов и откликов, т.е. Service <-> Service B и Service B <-> Service C. Запрос от Service B к Service C может 
выглядеть совершенно иначе, нежели от Service A к Service B. Аналогично, отклик от Service B к Service A может 
принципиально отличаться от отклика Service C к Service B. Это наиболее важно во всех случаях, когда бизнес-ценность 
нескольких сервисов суммируется.

Здесь также важно понять, что нельзя делать цепочку слишком длинной. Это критично, поскольку цепочка синхронна по 
своей природе, и чем она длиннее, тем дольше придется ожидать клиенту, особенно если отклик заключается в выводе 
веб-страницы на экран. Существуют способы обойти такой блокирующий механизм запросов и откликов, и они рассматриваются 
в следующем паттерне.

Цепочка, состоящая из единственного микросервиса, называется «цепочка-одиночка». Впоследствии ее можно расширить.
## Branch
Микросервисный паттерн проектирования «Ветка» расширяет паттерн «Агрегатор» и обеспечивает одновременную обработку 
откликов от двух цепочек микросервисов, которые могут быть взаимоисключающими. Этот паттерн также может применяться
для вызова различных цепочек, либо одной и той же цепочки – в зависимости от ваших потребностей.

![Branch](https://habrastorage.org/r/w1560/files/173/257/bca/173257bcaed04d97831a0691ec0c37ca.png)

Сервис A, будь то веб-страница или составной микросервис, может конкурентно вызывать две различные цепочки – и в этом 
случае будет напоминать агрегатор. В другом случае сервис А может вызывать лишь одну цепочку в зависимости от того,
какой запрос получит от клиента.

Такой механизм можно сконфигурировать, реализовав маршрутизацию конечных точек JAX-RS, в таком случае конфигурация 
должна быть динамической.
## Shared Data
Один из принципов проектирования микросервисов – автономность. Это означает, что сервис полностековый и контролирует 
все компоненты – пользовательский интерфейс, промежуточное ПО, сохраняемость, транзакции. В таком случае сервис может 
быть многоязычным и решать каждую задачу при помощи наиболее подходящих инструментов. Например, если при необходимости 
можно применить хранилище данных NoSQL, то лучше сделать именно так, а не забивать эту информацию в базу данных SQL.

Однако, типичная проблема, особенно при рефакторинге имеющегося монолитного приложения, связана с нормализацией базы 
данных — так, чтобы у каждого микросервиса был строго определенный объем информации, ни больше, ни меньше. Даже если 
в монолитном приложении используется только база данных SQL, ее денормализация приводит к дублированию данных, а 
возможно – и к несогласованности. На переходном этапе в некоторых приложениях бывает очень полезно применить 
паттерн «Разделяемые данные».

При этом паттерне несколько микросервисов могут работать о цепочке и совместно использовать хранилища кэша и базы 
данных. Это целесообразно лишь в случае, если между двумя сервисами существует сильная связь. Некоторые могут 
усматривать в этом антипаттерн, но в некоторых бизнес-ситуациях такой шаблон действительно уместен. Он определенно был
бы антипаттерном в приложении, которое изначально создается как микросервисное.

![Shared Data](https://habrastorage.org/r/w1560/files/3b0/6e8/f29/3b06e8f29f9f4a78a09e8afff9c79935.png)

Кроме того, его можно рассматривать как промежуточный этап, который нужно преодолеть, пока микросервисы не станут 
полностью автономными.
## Asynchronous Messaging
При всей распространенности и понятности паттерна REST, у него есть важное ограничение, а именно: он синхронный и, 
следовательно, блокирующий. Обеспечить асинхронность можно, но это делается по-своему в каждом приложении. Поэтому в 
некоторых микросервисных архитектурах могут использоваться очереди сообщений, а не модель REST запрос/отклик.

![Asynchronous Messaging](https://habrastorage.org/r/w1560/files/bec/4a4/2ec/bec4a42ec9d7476f90c7f8047957c87c.png)

В этом паттерне сервис А может синхронно вызывать сервис C, который затем будет асинхронно связываться с сервисами B и 
В при помощи разделяемой очереди сообщений. Коммуникация Service A -> Service C может быть асинхронной, скажем, 
с использованием веб-сокетов; так достигается желаемая масштабируемость. Комбинация модели REST запрос/отклик и обмена
сообщениями публикатор/подписчик также могут использоваться для достижения поставленных целей.
## Service Registry
Service Registry Pattern предоставляет центральное хранилище для поиска микросервисов по имени. Это шаблон архитектуры
микросервиса, который позволяет службам обнаруживать другие микросервисы и взаимодействовать друг с другом.

В этом шаблоне центральный реестр служб или каталог используется для ведения записей о доступных службах и их 
местоположениях. Микросервисы могут регистрировать себя в реестре, а другие микросервисы могут просматривать реестр, 
чтобы найти местоположение требуемых служб.

Например, предположим, что у нас есть большой веб-сайт электронной коммерции, который состоит из множества 
микросервисов, таких как служба заказов, платёжная служба, служба доставки и служба поддержки клиентов. Каждая из 
этих служб имеет свой собственный REST API, который другие службы могут использовать для взаимодействия с ней.

Чтобы этим службам было проще обнаруживать друг друга, мы можем использовать Service Registry Pattern. Мы можем 
настроить реестр служб, таких как Consul или Eureka (Spring cloud предоставляет это), который поддерживает список 
всех доступных служб и их конечных точек.

Когда служба запускается, она может зарегистрировать себя в реестре, указав своё имя и конечную точку.

Например, служба заказов может зарегистрировать себя как “служба заказов” с конечной точкой 
“http://order-service:8080". Другие службы, которым необходимо взаимодействовать со службой заказа, могут затем найти 
её конечную точку в реестре, используя её имя.

Например, платёжная служба может искать конечную точку “служба заказов” в реестре, чтобы отправить платёжную информацию 
в службу заказов. Аналогично, служба доставки может искать конечную точку “заказ-сервис” в реестре, чтобы получить 
информацию о доставке для заказа.

Таким образом, каждая служба может быть разработана и развёрнута независимо, без кодирования конечных точек других 
служб в её коде. Service Registry Pattern позволяет службам динамически находить друг друга, делая систему более 
гибкой и устойчивой к изменениям.

![Service Registry](https://leonardo.osnova.io/94413388-3782-530a-b2b6-866fcfbcb0c9/-/preview/600x/-/format/webp)
## Circuit Breaker паттерн
Circuit Breaker Pattern предотвращает каскадный сбой путём разрыва цепи и позволяет приложениям продолжать 
функционировать при сбое одной или нескольких служб. Он используется для обработки ошибок, которые могут возникать 
в микросервисной архитектуре.

В этом случае Circuit Breaker Pattern действует как защитная сетка между клиентом и сервисом, защищая клиента от сбоев
в работе сервиса. Circuit Breaker Pattern отслеживает состояние службы и, если он обнаруживает, что служба выходит 
из строя, он может разомкнуть цепь и предотвратить отправку дальнейших запросов в службу до тех пор, пока служба 
не восстановится.

Например, предположим, что микросервисное приложение использует внешнюю службу, которая ненадёжна, и приложению
необходимо продолжать функционировать, даже если внешняя служба выходит из строя.

В этом сценарии шаблон Circuit Breaker Pattern может использоваться для определения того, когда внешняя служба 
недоступна, и переключения на альтернативную службу или резервную службу до тех пор, пока внешняя служба снова 
не станет доступной.

![Circuit Breaker Pattern](https://leonardo.osnova.io/07cfb462-0593-5147-8813-784851f803bb/-/preview/600x/-/format/webp)

В микросервисной архитектуре шаблон Circuit Breaker Pattern может быть реализован с помощью таких инструментов, 
как Hystrix от Netflix или Spring Cloud Circuit Breaker, которые обеспечивают способ управления поведением 
Circuit Breaker Pattern и позволяют приложению реагировать на сбои в обслуживании контролируемым образом.
## API Gateway
API Gateway Pattern - это ещё один распространённый шаблон проектирования, используемый в архитектуре микросервисов, 
который включает API gateway, который действует как точка входа для всех входящих запросов API. Он обеспечивает единую
точку входа для всех микросервисов и действует как прокси-сервер между клиентами и микросервисами, направляя запросы 
в соответствующую службу.

Основная цель API Gateway Pattern - отделить клиентов от микросервисов, абстрагируя сложность системы за упрощённым и 
согласованным API. Это также означает, что вам не нужно находить и запоминать адреса более чем 100 микросервисных
REST API.

Этот микросервис обеспечивает дополнительный уровень безопасности и управления, позволяя организациям контролировать
доступ к своим службам и управлять ими, отслеживать производительность системы и применять политики во всех службах.

Вот пример того, как API Gateway Pattern работает в простой системе электронной коммерции:

Предположим, система электронной коммерции имеет несколько микросервисов для обработки различных функций, таких как 
управление заказами, каталог товаров и аутентификация пользователя. Каждый микросервис имеет свою собственную конечную 
точку API для обработки запросов. Однако клиенту, которым может быть веб-приложение или мобильное приложение,
необходимо получить доступ ко всем этим микросервисам через единую точку входа.

Вот тут-то и вступает в игру API Gateway Pattern. Он действует как обратный прокси-сервер, который получает все 
входящие запросы от клиентов. Затем он направляет каждый запрос в соответствующий микросервис на основе запрошенной
конечной точки.

Например, API Gateway Pattern может направлять запросы к конечной точке /orders в микросервис управления заказами, 
а запросы к конечной точке /products - в микросервис каталога продуктов.

![API Gateway](https://leonardo.osnova.io/4b744e89-711d-56f4-a8b4-a55d281221d2/-/preview/600x/-/format/webp)

API Gateway Pattern также может выполнять дополнительные функции, такие как преобразование запросов и ответов, 
ограничение скорости, аутентификация и авторизация, а также кэширование.

Он также может предоставить унифицированный API, который скрывает внутренние детали микросервисов и представляет
клиентам более простой и согласованный интерфейс.

В целом, API Gateway Pattern обеспечивает масштабируемый, гибкий и безопасный способ управления микросервисами в 
сложной системе, упрощая разработку, развёртывание и обслуживание приложений на основе микросервисов.

![API Gateway](https://leonardo.osnova.io/91b07d75-4d62-504b-8bdd-584e40d91935/-/preview/600x/-/format/webp)
## Паттерн Saga
Saga Pattern предоставляет способ управления транзакциями, в которых задействовано несколько микросервисов. Он
используется для обеспечения успешного завершения серии транзакций в нескольких службах, а если нет, то для отката или
отмены всех изменений, которые были внесены до этого момента.

Saga Pattern состоит из последовательности локальных транзакций, каждая из которых обновляет состояние отдельной
службы, и соответствующего набора компенсирующих транзакций, которые используются для отмены последствий исходных
транзакций в случае сбоя.

Вот пример того, как Saga Pattern используется в приложении электронной коммерции на основе микросервиса:

Предположим, у вас есть два микросервиса, один из которых отвечает за обработку заказов, а другой - за доставку заказов.

При размещении нового заказа служба обработки заказов отвечает за подтверждение заказа и обеспечение наличия товаров
на складе, в то время как служба доставки отвечает за упаковку заказа и отправку его клиенту.

Если служба обработки заказов определяет, что заказ действителен и все товары есть на складе, она отправляет сообщение
службе доставки, чтобы инициировать процесс доставки. На этом этапе в игру вступает Saga Pattern.

Служба доставки создаст новую транзакцию для упаковки и отправки заказа, и если транзакция пройдёт успешно, она пометит
заказ как отправленный.

Если, с другой стороны, транзакция завершится неудачей (возможно, из-за проблемы с поставщиком доставки), служба
доставки инициирует компенсирующую транзакцию, чтобы отменить последствия первоначальной транзакции, такие как отмена
отправки и пополнение запасов товаров.

![Saga](https://leonardo.osnova.io/8d92d974-47c0-5468-b4f8-7cbe8b0dd7dc/-/preview/600x/-/format/webp)

Между тем, служба обработки заказов также использует Saga Pattern для управления своей собственной транзакцией. Если
служба доставки сообщает, что заказ был успешно отправлен, служба обработки заказов отметит заказ как выполненный.

Если служба доставки сообщит о сбое, служба обработки заказа инициирует компенсирующую транзакцию, чтобы отменить заказ
и вернуть все уплаченные средства.

В целом, Saga Pattern предоставляет способ управления сложными транзакциями между несколькими микросервисами таким
образом, чтобы обеспечить согласованность и надёжность. Если вам нужно выучить только один инструмент, вам лучше
изучить Saga Patterns, поскольку они чрезвычайно полезны в микросервисных приложениях.
## Event Sourcing Pattern
Event Sourcing Pattern - это шаблон микросервиса, используемый для сохранения и запроса данных в приложении. Вместо 
сохранения текущего состояния объекта, Event Sourcing сохраняет все события, которые происходят в приложении, позволяя 
восстанавливать состояние объекта в любой момент времени.

В этом шаблоне каждое изменение состояния в приложении фиксируется как событие и сохраняется в виде журнала событий. 
Состояние приложения может быть восстановлено путём воспроизведения этих событий. Это означает, что источник событий 
предоставляет журнал всех изменений, которые происходят в приложении.

Например, рассмотрим приложение для электронной коммерции. Когда пользователь размещает заказ, генерируется событие 
OrderPlaced, которое сохраняется в журнале. Когда заказ отправлен, генерируется событие ShipmentMade, которое 
сохраняется в журнале.

Если заказ отменён, генерируется событие OrderCanceled, которое сохраняется в журнале. Путём воспроизведения событий 
можно определить текущее состояние заказа.

![Event Sourcing Pattern](https://leonardo.osnova.io/b0ae7279-9bbe-51a3-ba22-43cbb811b9bd/-/preview/600x/-/format/webp)

Event Sourcing Pattern имеет несколько преимуществ:
- Проверяемость: Все изменения в системе могут быть проверены.
- Масштабируемость: События могут обрабатываться параллельно, что обеспечивает лучшую масштабируемость.
- Гибкость: Поскольку события являются источником истины, можно изменить способ запроса и сохранения данных без
изменения самих данных.
- Отказоустойчивость: Поскольку события неизменяемы, они не могут быть изменены, гарантируя, что данные всегда верны.

Однако внедрение Event Sourcing Pattern может быть сложным и требует тщательного планирования. Кроме того, запрос данных 
может быть медленнее, поскольку он включает в себя воспроизведение всех событий, поэтому вы должны убедиться, что они 
вам действительно нужны, прежде чем использовать их.
## Command Query Responsibility Segregation (CQRS) Pattern
Command Query Responsibility Segregation (CQRS) Pattern - это ещё один популярный шаблон проектирования микросервисов,
который разделяет команды (операции записи) и запросы (операции чтения) на отдельные модели, каждая со своей 
собственной базой данных.

Шаблон основан на идее, что модели, используемые для записи данных, не совпадают с моделями, используемыми для
чтения данных.

В этом шаблоне командная модель получает команды от клиента и записывает их в базу данных. Модель запроса считывает 
данные из базы данных и отправляет их клиенту. Шаблон может быть использован для повышения производительности и 
масштабируемости системы, поскольку каждая модель может быть оптимизирована для своей конкретной задачи.

Например, рассмотрим приложение для электронной коммерции, которое использует традиционный подход к управлению 
информацией о продукте на основе CRUD. Одна и та же модель и база данных используются как для чтения, так и для записи 
информации о продукте. По мере роста приложения модель становится всё более сложной, а база данных начинает снижать
производительность этого приложения.

Используя CQRS, приложение будет иметь отдельную модель команд для записи информации о продукте и отдельную модель 
запросов для чтения информации о продукте. Модель команд была бы оптимизирована для быстрой записи, в то время как 
модель запросов была бы оптимизирована для быстрого чтения.

Command Model будет хранить данные в базе данных, оптимизированной для записи, в то время как модель запросов будет 
хранить данные в базе данных, оптимизированной для чтения. Две модели будут взаимодействовать через шину событий или
очередь сообщений.

В целом, CQRS может улучшить масштабируемость и производительность системы, а также упростить кодовую базу за счёт 
разделения функционала. Однако, это также может усложнить и потребовать дополнительных усилий по разработке, поскольку 
требуются отдельные модели и базы данных.
## Bulkhead Pattern
Bulkhead Pattern - это способ изоляции различных частей системы таким образом, чтобы сбой в одной части не повлиял на 
остальную систему. В микросервисной архитектуре Bulkhead Pattern может использоваться для изоляции различных 
микросервисов, чтобы сбой в одном микросервисе не приводил к выходу из строя всей системы.

Это выглядит очень похоже на Circuit Breaker Pattern, который также предотвращает каскадный сбой, но вместо разрыва
цепи этот шаблон проектирования фокусируется на изоляции и самодостаточных микросервисах, как показано на диаграмме
ниже. Служба A имеет свой собственный пул подключений, который не используется совместно между службами B и C.

![Bulkhead Pattern](https://leonardo.osnova.io/ab5dc327-96a9-5c1b-a7e7-fe960b299f8d/-/preview/600x/-/format/webp)
## Backends for Frontends (BFF)
Backends for Frontends (BFF) - это шаблон проектирования, используемый в микросервисной архитектуре для обработки 
сложности взаимодействия клиент-сервер в контексте множества пользовательских интерфейсов. Он предполагает наличие 
отдельной серверной службы для каждого интерфейса для удовлетворения конкретных потребностей этого интерфейса.

Это позволяет разработчикам оптимизировать потоки данных, механизмы кэширования и аутентификации для уникальных 
потребностей интерфейсной части, сохраняя при этом модульность и несвязанность внутренних служб.

Например, предположим, что у вас есть веб-приложение и мобильное приложение, которым необходим доступ к одному и тому
же набору служб. В этом случае вы можете создать отдельные серверные службы для каждого приложения, каждая из которых 
оптимизирована для конкретной платформы.

Серверная часть веб-приложения может обрабатывать большие объёмы данных для более быстрой загрузки, в то время как 
серверная часть мобильного приложения может оптимизировать для снижения задержек и использования сети.

Этот шаблон позволяет командам оптимизировать пользовательский интерфейс для каждого интерфейса, используя отдельные
внутренние службы для каждого из них. Это также позволяет им избежать наличия единой серверной службы, которая должна 
обслуживать множество различных интерфейсов с разными потребностями, что может становиться всё более сложным и 
труднодоступным в обслуживании.
## Load Balancing Pattern
Шаблон Load Balancing — ключ к равномерному распределению трафика между вашими сервисами, обеспечивающий оптимальную 
производительность и предотвращая перегрузку сервисов.

С ростом вашего приложения неравномерное распределение трафика может привести к ухудшению работы сервисов или даже их 
отказу. Балансировка нагрузки гарантирует, что ни один сервис не станет узким местом, что приводит к улучшению 
производительности и надежности системы.

Балансировка нагрузки может быть реализована с использованием различных алгоритмов, таких как round-robin, 
least connections и weighted round-robin. Каждый алгоритм имеет свои преимущества и применение, поэтому важно выбрать 
подходящий для вашей системы. Инструменты, такие как NGINX и HAProxy, предлагают мощные решения для балансировки
нагрузки, позволяя настраивать стратегию распределения трафика с высокой точностью.

![Load balancing Pattern](https://leonardo.osnova.io/89235f37-65f3-53ef-9e90-a7be15b8edeb/-/preview/600x/-/format/webp)
## Retry Pattern: корректное восстановление после ошибок
Этот шаблон предусматривает автоматическое повторение неудачной операции, увеличивая вероятность успешного выполнения и
минимизируя влияние временных сбоев.

В экосистеме микросервисов неизбежны временные сбои, такие как сбои в сети или таймаут ожидания сервиса. Шаблон Retry 
позволяет вашим сервисам корректно восстанавливаться после таких проблем, повышая общую стабильность системы.

Ключевым моментом успешной реализации является определение подходящей стратегии повторных попыток. Эта стратегия 
должна включать факторы, такие как максимальное количество повторов, задержку между повторами и, возможно, 
экспоненциальное замедление. Библиотеки, такие как Polly, Resilience4j и Spring Retry, предоставляют встроенную 
поддержку для реализации шаблона Retry в ваших микросервисах.
## Sidecar Pattern: модульная функциональность для микросервисов
Паттерн Sidecar позволяет добавлять дополнительные компоненты к вашим сервисам, предоставляя модульную функциональность
без изменения основного сервиса.

В микросервисной архитектуре крайне важно сохранять независимость сервисов. Шаблон Sidecar позволяет добавлять новые
функции и задачи, не влияя на основной сервис, а также сохраняя модульность и удобство сопровождения.

Реализация шаблона Sidecar включает развертывание отдельного контейнера рядом с основным сервиса. Этот дополнительный
контейнер обрабатывает конкретные задачи, такие как логирование, мониторинг или безопасность, позволяя основному 
сервису сосредоточиться на его основной функциональности. Примеры реализации Sidecar включают прокси-сервер Envoy в 
сервисной сети и контейнер для логирования Fluentd.
