# Жизненный цикл Hibernate Entity-объектов
## Оглавление
## Список состояний
Если у тебя есть какой-то Entity-объект, который ты можешь сохранять в базу с помощью Hibernate, то с точки зрения 
Hibernate у этого объекта может быть четыре состояния:
- Transient
- Persistent (or Managed)
- Detached
- Removed

![Hibernate Entity Lifecycle](https://cdn.javarush.com/images/article/d79ec4c4-75c1-4ae4-b7c9-8672e38dee58/1024.webp)
## Transient
Каждый Entity объект, который ты создал явно с помощью Java-кода, а не загрузил из базы с помощью Hibernate, имеет
статус Transient (прозрачный).
```java
EmployeeEntity employee = new EmployeeEntity();
```
Статус Transient значит, что Hibernate понятия не имеет об этом объекте, и никакие действия с объектом не влияют на
Hibernate, как и работа Hibernate на этот объект.

Если некий клиентский код работает с объектом со статусом Transient, то их взаимодействие можно описать
супер-простой схемой:

![Transient Object](https://cdn.javarush.com/images/article/53224fad-6579-4469-845a-0f1bb13e9a86/256.webp)
## Persistent or Managed
Следующий самый распространенный случай – это объекты, связанные с движком Hibernate. Их статус называют Persistent
(или же Managed). Способов получить объект с таким статусом ровно два:
- Загрузить объект из Hibernate.
- Сохранить объект в Hibernate.

Примеры:
```java
Employee employee = session.load(Employee.class, 1);
//----------------------------------------------------
Employee employee = new Employee();
session.save(employee);
```
Такому объекту обычно соответствует какая-то запись в базе данных, у него есть ID и тому подобное. Этот объект
присоединен к сессии Hibernate’а, и вообще может быть представлен не реальным объектом, а неким proxy.

Вполне реальна ситуация, когда после вызова метода session.load(), тебе вернут некий объект-заглушку (proxy), и все
обращения к базе данных будут выполняться только после вызова методов этого объекта.

А взаимодействие клиентского кода и объекта в статусе Managed можно описать вот такой картинкой:

![Persistent Object](https://cdn.javarush.com/images/article/a3dbbcc1-397b-4695-954b-5c52073850ba/800.webp)
## Detached
Следующее состояние – это когда объект был отсоединен от сессии. То есть когда-то объект был присоединен к сессии 
Hibernate, но затем сессия закрылась или транзакция завершилась, и Hibernate больше не следит за этим объектом.

Пример:
```java
session.close();
//----------------------------------------------------
session.evict(entity);
```
В первом примере сессия была закрыта. Во втором случае мы явно указали, что хотим отсоединить объект от сессии с 
помощью метода evict().

Новая схема взаимодействия кода и объекта будет выглядеть так:

![Detached Object](https://cdn.javarush.com/images/article/cd4dfefa-63c3-4026-b48a-b7b2cf5b95e0/800.webp)

И вот тут будет самое интересное. Если твой объект был получен из Hibernate, то велика вероятность, что тебе отдали
некий proxy вместо реального объекта. И этот proxy-объект после отсоединения от сессии будет кидать исключения при 
вызове его методов.

Это самая частая проблема у всех новичков при работе с Hibernate. Тебе нужно точно знать в каждый момент времени ответ
на такие вопросы, когда ты работаешь с Entity-объектом:
- У тебя реальный объект или только proxy от реального объекта?
- Ты сейчас в транзакции или нет?
- Это read-write транзакция или read-only транзакция?
- Объект управляется механизмом LazyLoading?
- Какие части объекта уже загружены в память, а какие будет загружены при обращении?
- Как твой объект соединен с зависимыми объектами?
## Removed
И последнее состояние, которое может быть у твоего Entity-объекта – это Removed. Как ты уже наверное догадался из его
названия – это состояние удаленного объекта.

Такое состояние появляется по причине того, что если ты удалишь какой-то объект из базы, то Java-объект сразу никуда
не исчезнет.
```java
Employee employee = session.load(Employee.class, 1);
//после загрузки у объекта состояние Persisted

session.remove(employee);
//после удаления у объекта состояние Removed

session.save(employee);
//а теперь снова Persisted

session.close();
//а теперь состояние Detached
```
