# Hibernate Cache
## Оглавление
- [Уровни кеширования](#уровни-кеширования)
  - [Кеш первого уровня](#кеш-первого-уровня)
  - [Кеш второго уровня](#кеш-второго-уровня)
  - [Кеш третьего уровня](#кеш-запросов)
- [Стратегии кеширования](#стратегии-кеширования)
- [Cache Region](#cache-region)
- [Дополнительно](#дополнительно)
## Уровни кеширования
Есть 3 уровня кеширования:
- Кеш первого уровня (First-level cache) - кеш привязан к объекту сессии
- Кеш второго уровня (Second-level cache) - кеш привязан к объекту-фабрике сессий
- Кеш запросов (Query cache) - кеш привязан к запросу
## Кеш первого уровня
Кеш первого уровня всегда привязан к объекту сессии. Hibernate всегда по умолчанию использует этот кеш и его нельзя 
отключить. Сразу рассмотрим следующий код:
```java
SharedDoc persistedDoc = (SharedDoc) session.load(SharedDoc.class, docId);
System.out.println(persistedDoc.getName());
user1.setDoc(persistedDoc);

persistedDoc = (SharedDoc) session.load(SharedDoc.class, docId);
System.out.println(persistedDoc.getName());
user2.setDoc(persistedDoc);
```
Возможно, мы ожидаем, что будет выполнено 2 запроса в БД, но это не так. В этом примере будет выполнен 1 запрос в базу, 
несмотря на то, что делается 2 вызова load(), т.к. эти вызовы происходят в контексте одной сессии. Во время второй 
попытки загрузить план с тем же идентификатором будет использован кеш сессии.

Один важный момент - при использовании метода load() Hibernate не выгружает из БД данные до тех пор, пока они не 
потребуются. Иными словами - в момент, когда осуществляется первый вызов load(), мы получаем прокси объект или сами 
данные в случае, если данные уже были в кеше сессии. Поэтому в коде присутствует getName(), чтобы 100% вытянуть данные 
из БД. Тут также открывается прекрасная возможность для потенциальной оптимизации. В случае прокси объекта мы можем 
связать 2 объекта, не делая запрос в базу, в отличие от метода get(). При использовании методов save(), update(), 
saveOrUpdate(), load(), get(), list(), iterate(), scroll() всегда будет задействован кеш первого уровня.
## Кеш второго уровня
Если кеш первого уровня привязан к объекту сессии, то кеш второго уровня привязан к объекту-фабрике сессий (Session 
Factory object). Что как бы подразумевает, что видимость этого кеша гораздо шире первого уровня. Пример:
```java
Session session = factory.openSession();
SharedDoc doc = (SharedDoc) session.load(SharedDoc.class, 1L);
System.out.println(doc.getName());
session.close();

session = factory.openSession();
doc = (SharedDoc) session.load(SharedDoc.class, 1L);
System.out.println(doc.getName());
session.close();
```
В данном примере будет выполнено 2 запроса в базу, это связано с тем, что по умолчанию кеш второго уровня отключён. Для 
включения необходимо добавить следующие строки в конфигурационном файле JPA (persistence.xml):
```xml
<property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletonEhCacheProvider"/>
<!--или в более старых версиях:-->
<!--<property name="hibernate.cache.provider_class" value="org.hibernate.cache.EhCacheProvider"/>-->
<property name="hibernate.cache.use_second_level_cache" value="true"/>
```
На самом деле hibernate сам не реализует кеширование как таковое, а лишь предоставляет структуру для его реализации, 
поэтому подключить можно любую реализацию, которая соответствует спецификации нашего ORM-фреймворка. Популярные 
реализации:
- EHCache
- OSCache
- SwarmCache
- JBoss TreeCache

Помимо всего этого, вероятней всего, также потребуется отдельно настроить саму реализацию кеша. В случае с EHCache это 
нужно сделать в файле ehcache.xml. Ну и в завершение нужно указать самому hibernate, что именно кешировать. Например, 
аннотацией:
```java
@Entity
@Table(name = "shared_doc")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc {
    private Set<User> users;
}
```
Только для всех этих манипуляций кеш второго уровня будет включён и в примере выше будет выполнен только 1 запрос в 
базу. 

Ещё одна важная деталь про кеш второго уровня - Hibernate не хранит сами объекты классов. Он хранит информацию в виде 
массивов строк, чисел и т.д. Идентификатор объекта выступает указателем на эту информацию, концептуально это вроде Map, 
в которой id объекта - ключ, а массив данных - значение:
```
1 -> {"Ivanov", 1, null, {1, 2, 3}}
```
Зависимости класса также не кешируются. Если посмотреть выше, то при выборке коллекция users будет доставаться из БД, а 
не из кеша второго уровня. Если нужно кешировать зависимости, то класс должен выглядеть так:
```java
@Entity
@Table(name = "shared_doc")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class SharedDoc {
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    private Set<User> users;
}
```
Чтение из кеша второго уровня будет происходить только если объект не был найден в кеше второго уровня.
## Кеш запросов
```java
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");

SharedDoc persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user1.setDoc(persistedDoc);

persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user2.setDoc(persistedDoc);
```
Результаты такого уровня запросов не сохраняются кешами первого и второго уровней, нужно использовать кеш запросов, 
который также по умолчанию отключён. Для включения нужно добавить следующую строку в конфигурационный файл:
```xml
<property name="hibernate.cache.use_query_cache" value="true"/>
```
А также переписать пример выше, добавив после создания объекта Query:
```java
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");
query.setCacheable(true);
```
Кеш запросов похож на кеш второго уровня. Но в отличие от него - ключом к данным кеша выступает не идентификатор 
объекта, а совокупность параметров запроса. А сами данные - это идентификаторы объектов соответствующих критериям 
запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня.
## Стратегии кеширования
Стратегии кеширования определяют поведения кеша в определённых ситуациях. Выделяют 4 группы:
- Read-only - если необходимо читать, но не изменять экземпляры класса, можно использовать кэш только для чтения. 
Это самая простая и оптимальная стратегия. Является безопасной для использования в кластере.
- Read-write - если необходимо обновлять данные, может подойти кэш чтения-записи. Эта стратегия кэширования никогда не 
должна использоваться, если требуется сериализуемый уровень изоляции транзакций. Если кэш используется в среде JTA, вы 
должны указать свойство hibernate.transaction.manager_lookup_class и назвать стратегию получения JTA TransactionManager. 
В других средах вы должны убедиться, что транзакция завершается при вызове Session.close() или Session.disconnect(). 
Если вы хотите использовать эту стратегию в кластере, вам следует убедиться, что базовая реализация кэша поддерживает 
блокировку. Встроенные провайдеры кэша не поддерживают блокировку.
- Nonstrict-read-write - Если приложение лишь изредка нуждается в обновлении данных (т. е. крайне маловероятно, что две 
транзакции попытаются обновить один и тот же элемент одновременно), а строгая изоляция транзакций не требуется, может 
подойти нестрогий кэш чтения-записи. Если кэш используется в среде JTA, необходимо указать 
hibernate.transaction.manager_lookup_class. В других средах необходимо убедиться, что транзакция завершена при вызове 
Session.close() или Session.disconnect().
- Transactional - Если приложение лишь изредка нуждается в обновлении данных (т. е. крайне маловероятно, что две 
транзакции попытаются обновить один и тот же элемент одновременно), а строгая изоляция транзакций не требуется, может 
подойти нестрогий кэш чтения-записи. Если кэш используется в среде JTA, необходимо указать 
hibernate.transaction.manager_lookup_class. В других средах необходимо убедиться, что транзакция завершена при вызове 
Session.close() или Session.disconnect().
## Cache Region
Регион или область - это логический разделитель памяти вашего кеша. Для каждого региона можно настроить свою политику
кеширования (для EhCache в том же ehcache.xml). Если регион не указан, то используется регион по умолчанию, который 
имеет полное имя вашего класса, для которого применяется кеширование. В коде:
```java
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE, reegion = "STATIC_DATA")
```
Для кеша запросов:
```java
query.setCacheRegion("STATIC_DATA");
// или для критерии:
criteria.setCacheRegion("STATIC_DATA");
```
## Дополнительно
Во время разработки приложения, особенно сначала, очень удобно видеть, действительно ли кешируются те или иные запросы, 
для чего нужно указать у фабрики сессий следующие свойства:
```xml
<property name="hibernate.show_sql" value="true"/>
<property name="hibernate.format_sql" value="true"/>
```
В дополнение фабрика сессий также может генерировать и сохранять статистику использования всех объектов, регионов, 
зависимостей в кеше:
```xml
<property name="hibernate.generate_statistics" value="true"/>
<property name="hibernate.cache.use_structured_entries" value="true"/>
```
Для этого есть объекты Statistics для фабрики и SessionStatistics для сессии.

Методы сессии:
- flush() - синхронизирует объекты сессии с БД и в то же время обновляет сам кеш сессии.
- evict() - нужен для удаления объекта из кеша сессии.
- contains() - определяет, находится ли объект в сессии.
- clear() - очищает весь кеш.
