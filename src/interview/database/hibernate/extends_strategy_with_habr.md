# Наследование в Hibernate: выбор стратегии
## Оглавление
- [Описание](#описание)
- [Типы стратегий](#типы-стратегий)
- [Факторы выбора стратегии](#факторы-выбора-стратегии)
- [Стратегия 1: одна таблица для каждого класса](#стратегия-1-одна-таблица-для-каждого-класса)
- [Стратегия 2: одна таблица для каждого класса с объединениями (UNION)](#стратегия-2-одна-таблица-для-каждого-класса-с-объединениями-union)
- [Стратегия 3: единая таблица для всей иерархии классов](#стратегия-3-единая-таблица-для-всей-иерархии-классов)
- [Стратегия 4: одна таблица для каждого класса с использованием соединений (JOIN)](#стратегия-4-одна-таблица-для-каждого-класса-с-использованием-соединений-join)
- [Смешение стратегий отображения наследования](#смешение-стратегий-отображения-наследования)
- [Выбор стратегии](#выбор-стратегии)
## Описание
Наследование является одним из основных принципов ООП. В то же время, значительное количество корпоративных приложений 
имеют в своей основе реляционные базы данных

Главное противоречие между объектно-ориентированной и реляционной моделями заключается в том, объектная модель 
поддерживает два вида отношений («is a» — “является”, и «has a» — “имеет”), а модели, основанные на SQL, поддерживают
только отношения «has a».

Иными словами, SQL не понимает наследование типов и не поддерживает его.

Поэтому на этапе построения сущностей и схемы БД одной из главных задач разработчика будет выбор оптимальной стратегии 
представления иерархии наследования.
## Типы стратегий
1) Использовать одну таблицу для каждого класса и полиморфное поведение по умолчанию
2) Одна таблица для каждого конкретного класса, с полным исключением полиморфизма и отношений наследования из схемы SQL 
(для полиморфного поведения во время выполнения будут использоваться UNION-запросы)
3) Единая таблица для всей иерархии классов. Возможна только за счет денормализации схемы SQL. Определять суперкласс и 
подклассы будет возможно посредством различия строк.
4) Одна таблица для каждого подкласса, где отношение “is a” представлено в виде «has a», т.е. – связь по внешнему ключу 
с использованием JOIN.
## Факторы выбора стратегии
1) Производительность (мы используем “hibernate_show_sql”, чтобы увидеть и оценить все выполняемые к БД запросы)
2) Нормализация схемы и гарантия целостности данных (не каждая стратегия гарантирует выполнение ограничения NOT NULL)
3) Возможность эволюции вашей схемы
## Стратегия 1: одна таблица для каждого класса
Диаграмма классов:

![диаграмма классов](https://habrastorage.org/r/w1560/getpro/habr/post_images/3b5/974/f53/3b5974f533b24e6f1ed9fdea8300898c.jpg)

Классы BankAccount и CreditCard наследуются от общего абстрактного предка BillingDetails. Как видно из схемы, несмотря 
на похожий функционал, их состояния существенно отличаются: для карты нам важны номер и срок действия, а для 
банковского счета – поля реквизитов.

Родительский класс хранит только общую для всех потомков информацию о владельце. Кроме того, туда можно вынести, 
например, поле Id вместе с типом генерации (в данном случае мы обошлись без этого).

Схема нашей БД для первой стратегии будет выглядеть так:

![схема бд](https://habrastorage.org/r/w1560/getpro/habr/post_images/55e/7f1/3b0/55e7f13b07ebb30d8122d83cb2a4de7b.jpg)

ВАЖНО! Свойства суперкласса по умолчанию будут проигнорированы. Чтобы сохранить их в таблицу конкретного подкласса, 
необходимо использовать аннотацию @MappedSuperClass.

Отображение подклассов не содержит ничего необычного. Единственное, на что следует обратить внимание – возможно, 
незнакомая для некоторых аннотация @AttributeOverride. Она используется для переименования столбца в таблице подкласса, 
в том случае если названия у предка и таблицы потомка не совпадают (в нашем случае – чтобы «owner» из BillingDetails
маппился на CC_OWNER в таблице CREDIT_CARD).

Главная проблема при использовании данной стратегии заключается в том, что использовать полиморфные ассоциации в полной 
мере будет невозможно: обычно они представлены в БД в виде доступа по внешнему ключу, а у нас попросту нет таблицы 
BILLING_DETAILS. А поскольку каждый объект BillingDetails будет в приложении связан с конкретным объектом User, то 
каждой из таблиц-«потомков» нужен будет внешний ключ, ссылающийся на таблицу USERS.

Кроме того, проблемой также будут и полиморфные запросы.

Попробуем выполнить запрос:
```hql
SELECT bd FROM BillingDetails bd
```
В данном случае он будет выполнен следующим образом:
```
Hibernate: 
    select
        bankaccoun0_.id as id1_1_,
        bankaccoun0_.owner as owner2_1_,
        bankaccoun0_.account as account3_1_,
        bankaccoun0_.bank_name as bank_nam4_1_,
        bankaccoun0_.swift as swift5_1_ 
    from
        BANK_ACCOUNT bankaccoun0_
Hibernate: 
    select
        creditcard0_.id as id1_2_,
        creditcard0_.owner as owner2_2_,
        creditcard0_.card_number as card_num3_2_,
        creditcard0_.exp_month as exp_mont4_2_,
        creditcard0_.exp_year as exp_year5_2_ 
    from
        CREDIT_CARD creditcard0_
```
Иными словами, для каждого конкретного подкласса Hibernate использует отдельный SELECT-запрос.

Другой важной проблемой при использовании данной стратегии будет сложность рефакторинга. Изменение названия полей в 
суперклассе вызовет необходимость изменения названий во многих таблицах и потребует ручного переименования (инструменты 
большинства IDE не учитывают @AttributeOverride). В случае, если в вашей схеме не 2 таблицы, а 50, это чревато большими
временными затратами.

Этот подход возможно использовать только для верхушки иерархии классов, где:
- Полиморфизм не нужен (выборку для конкретного подкласса Hibernate будет выполнять в один запрос -> производительность
будет высокой)
- Изменения в суперклассе не предвидятся.

Для приложения, где запросы будут ссылаться на родительский класс BillingDetails эта стратегия не подойдет.
## Стратегия 2: одна таблица для каждого класса с объединениями (UNION)
В роли абстрактного класса вновь выступит BillingDetails. Схема БД также останется без почти без изменений.

Единственный момент – поле CC_OWNER в таблице CREDIT_CARD придется переименовать в OWNER, поскольку данная стратегия не 
поддерживает @AttributeOverride. Из документации: «The limitation of this approach is that if a property is mapped on 
the superclass, the column name must be the same on all subclass tables».

Новой также будет указанная над суперклассом аннотация @Inheritance с указанием выбранной стратегии TABLE_PER_CLASS.

ВАЖНО! В рамках данной стратегии наличие идентификатора в суперклассе является обязательным требованием (в первом
примере мы обошлись без него).

ВАЖНО! Согласно стандарту JPA стратегия TABLE_PER_CLASS не является обязательной, поэтому другими реализациями может
не поддерживаться.

Наша схема SQL по-прежнему ничего не знает о наследовании; между таблицами нет никаких отношений.

Главное преимущество данной стратегии можно увидеть, выполнив полиморфный запрос из предыдущего примера.
```hql
SELECT bd FROM BillingDetails bd
```
На сей раз он будет выполнен по-другому:
```
Hibernate: 
    select
        billingdet0_.id as id1_1_,
        billingdet0_.owner as owner2_1_,
        billingdet0_.card_number as card_num1_2_,
        billingdet0_.exp_month as exp_mont2_2_,
        billingdet0_.exp_year as exp_year3_2_,
        billingdet0_.account as account1_0_,
        billingdet0_.bank_name as bank_nam2_0_,
        billingdet0_.swift as swift3_0_,
        billingdet0_.clazz_ as clazz_ 
    from
        ( select
            id,
            owner,
            card_number,
            exp_month,
            exp_year,
            null::int4 as account,
            null::varchar as bank_name,
            null::varchar as swift,
            1 as clazz_ 
        from
            CREDIT_CARD 
        union
        all select
            id,
            owner,
            null::int4 as card_number,
            null::varchar as exp_month,
            null::varchar as exp_year,
            account,
            bank_name,
            swift,
            2 as clazz_ 
        from
            BANK_ACCOUNT 
    ) billingdet0_
```
В данном случае Hibernate использует FROM, чтобы извлечь все экземпляры BillingDetails из всех таблиц подклассов. 
Таблицы объединяются с помощью UNION, а в промежуточный результат добавляются литералы (1 и 2). Литералы используются 
Hibernate для создания экземпляра правильного класса.

Объединение таблиц требует одинаковой структуры столбцов, поэтому вместо несуществующих столбцов были вставлены NULL 
(например, «null::varchar as bank_name» в credit_card – в таблице кредиток нет названия банка).

Другим важный преимуществом по сравнению с первой стратегией будет возможность использовать полиморфные ассоциации. 
Теперь можно будет без проблем отобразить ассоциации между классами User и BillingDetails.
## Стратегия 3: единая таблица для всей иерархии классов
Иерархию классов можно целиком отобрать в одну таблицу. Она будет содержать столбцы для всех полей каждого класса 
иерархии. Для каждой записи конкретный подкласс будет определяться значением дополнительного столбца с селектором.

Наша схема теперь выглядит вот так:

![схема бд](https://habrastorage.org/r/w1560/getpro/habr/post_images/959/944/166/959944166b06bdf1f67ea752200c1af2.jpg)

Структура классов:

![структура классов](https://habrastorage.org/r/w1560/getpro/habr/post_images/765/19d/f17/76519df17b4fb8d1b07c1ee50c62f36c.jpg)

Для создания отображения с одной таблицей необходимо использовать стратегию наследования SINGLE_TABLE. Корневой класс 
будет отображен в таблицу BILLING_DETAILS. Для различения типов будет использован столбец селектора. Он не является 
полем сущности и создан только для нужд Hibernate. Его значением будут строки – “CC” или “BA”. ВАЖНО! Если не указать
столбец селектора в суперклассе явно – он получит название по умолчанию DTYPE и тип VARCHAR.

Каждый класс иерархии может указать свое значение селектора с помощью аннотации @DiscriminatorValue. Не стоит
пренебрегать явным указанием имени селектора: по умолчанию Hibernate будет использовать полное имя класса или имя 
сущности (зависит от того, используются ли файлы XML-Hibernate или xml-файлы JPA/аннотации).

Для проверки используем в методе main уже привычный запрос:
```hql
SELECT bd FROM BillingDetails bd
```
В случае с единой таблицей этот запрос будет выполнен так:
```
Hibernate: 
    select
        billingdet0_.id as id2_0_,
        billingdet0_.owner as owner3_0_,
        billingdet0_.card_number as card_num4_0_,
        billingdet0_.exp_month as exp_mont5_0_,
        billingdet0_.exp_year as exp_year6_0_,
        billingdet0_.account as account7_0_,
        billingdet0_.bank_name as bank_nam8_0_,
        billingdet0_.swift as swift9_0_,
        billingdet0_.BD_TYPE as BD_TYPE1_0_ 
    from
        BILLING_DETAILS billingdet0_
```
Если же запрос выполняется к конкретному подклассу – будет просто добавлена строка «where BD_TYPE = “CC”».

Вот как будет выглядеть отображение в единую таблицу:

![единая таблица](https://habrastorage.org/r/w1560/getpro/habr/post_images/833/a5d/f27/833a5df2711a38583c0f9de7bb501435.jpg)

В случае, когда схема была унаследована, и добавить в нее столбец селектора невозможно, на помощь приходит аннотация 
@DiscriminatorFormula, которую необходимо добавить к родительскому классу. В нее необходимо передать выражение
CASE...WHEN.

Главным плюсом данной стратегии является производительность. Запросы (как полиморфные, так и неполиморфные) выполняются 
очень быстро и могут быть легко написаны вручную. Не приходится использовать соединения и объединения. Эволюция схемы 
также производится очень просто.

Однако, проблемы, сопровождающие эту стратегию, часто будут перевешивать ее преимущества.

Главной из них является целостность данных. Столбцы тех свойств, которые объявлены в подклассах, могут содержать NULL.
В результате простая программная ошибка может привести к тому, что в базе данных окажется кредитная карта без номера
или без срока действия.

Другой проблемой будет нарушение нормализации, а конкретно – третьей нормальной формы. В этом свете выгоды от 
повышенной производительности уже выглядят сомнительно. Ведь придется, как минимум, пожертвовать удобством 
сопровождения: в долгосрочной перспективе денормализованные схемы не сулят ничего хорошего.
## Стратегия 4: одна таблица для каждого класса с использованием соединений (JOIN)
Структура классов:

![структура классов](https://habrastorage.org/r/w1560/getpro/habr/post_images/765/19d/f17/76519df17b4fb8d1b07c1ee50c62f36c.jpg)

Схема БД:

![схема бд](https://habrastorage.org/r/w1560/getpro/habr/post_images/9d8/af4/045/9d8af40459d8f7d81e4bd6f9ea34e2b9.jpg)

В Java-коде для создания такого отображения необходимо использовать стратегию JOINED.

Теперь при сохранении, например, экземпляра CreditCard Hibernate вставит две записи. В таблицу BILLING_DETAILS попадут 
свойства, объявленные в полях суперкласса BillingDetails, а значения полей подкласса CreaditCard будут записаны в 
таблицу CREDIT_CARD. Эти записи будут объединены общим первичным ключом.

Таким образом, схема была приведена в нормальное состояние. Эволюция схемы и определение ограничений целостности также 
осуществляются просто. Внешние ключи позволяют представить полиморфную ассоциацию с конкретным подклассом.

Выполнив запрос:
```hql
SELECT bd FROM BillingDetails bd
```
мы увидим следующую картину:
```hql
Hibernate: 
    select
        billingdet0_.id as id1_1_,
        billingdet0_.owner as owner2_1_,
        billingdet0_1_.card_number as card_num1_2_,
        billingdet0_1_.exp_month as exp_mont2_2_,
        billingdet0_1_.exp_year as exp_year3_2_,
        billingdet0_2_.account as account1_0_,
        billingdet0_2_.bank_name as bank_nam2_0_,
        billingdet0_2_.swift as swift3_0_,
        case 
            when billingdet0_1_.id is not null then 1 
            when billingdet0_2_.id is not null then 2 
            when billingdet0_.id is not null then 0 
        end as clazz_ 
    from
        BILLING_DETAILS billingdet0_ 
    left outer join
        CREDIT_CARD billingdet0_1_ 
            on billingdet0_.id=billingdet0_1_.id 
    left outer join
        BANK_ACCOUNT billingdet0_2_ 
            on billingdet0_.id=billingdet0_2_.id
```
BILLING_DETAILS:

![Таблица BILLING_DETAILS](https://habrastorage.org/r/w1560/getpro/habr/post_images/3b4/f59/c9c/3b4f59c9c5306c4a7f9d803d5bb88a88.jpg)

CREDIT_CARD:

![Таблица CREDIT_CARD](https://habrastorage.org/r/w1560/getpro/habr/post_images/2d5/3ca/ff1/2d53caff16fdc35edfcefbaa4b7a12c8.jpg)

BANK_ACCOUNT:

![Таблица BANK_ACCOUNT](https://habrastorage.org/r/w1560/getpro/habr/post_images/037/6f7/bfc/0376f7bfc8c39616b86f64325149dfce.jpg)

Предложение CASE…WHEN позволяет Hibernate определить конкретный подкласс для каждой записи. В нем проверяется наличие 
либо отсутствие строк в таблицах подклассов CREDIR_CARD и BANK_ACCOUNT с помощью литералов.

Подобную стратегию будет весьма непросто реализовать вручную. Даже реализовать отчеты на основе произвольных запросов 
будет значительно сложнее. Производительность также может оказаться неприемлемой для конкретного проекта, поскольку 
запросы потребуют соединения нескольких таблиц или многих последовательных операций чтения.
## Смешение стратегий отображения наследования
При работе со стратегиями TABLE_PER_CLASS, SINGLE_TABLE и JOINED значительным неудобством является тот факт, что между 
ними невозможно переключаться. Выбранной стратегии придется придерживаться до конца (либо полностью менять схему).
Но есть приемы, с помощью которых можно переключить стратегию отображения для конкретного подкласса.

Например, отобразив иерархию классов в единственную таблицу (стратегия 3), можно выбрать для отдельного подкласса 
стратегию с отдельной таблицей и внешним ключом (стратегия 4).

Структура классов:

![структура классов](https://habrastorage.org/r/w1560/getpro/habr/post_images/765/19d/f17/76519df17b4fb8d1b07c1ee50c62f36c.jpg)

Схема БД:

![схема бд](https://habrastorage.org/r/w1560/getpro/habr/post_images/546/3f1/acb/5463f1acb665fe8c32645dae18cbcc99.jpg)

Теперь мы можем отобразить подкласс CreditCard в отдельную таблицу.
Для этого нам нужно будет применить стратегию InheritanceType.SINGLE_TABLE к суперклассу BillingDetails, а в работе с 
классом CreditCard нам поможет аннотация @SecondaryTable.

При помощи аннотаций @SecondaryTable и @Column мы переопределяем основную таблицу и ее столбцы, указывая Hibernate, 
откуда необходимо брать данные.

При выборе стратегии SINGLE_TABLE столбцы подклассов могут содержать NULL. Используя же данный прием, вы можете 
гарантировать целостность данных для конкретного подкласса (в нашем случае — CreditCard). Исполняя полиморфный запрос,
Hibernate выполнит внешнее соединение для извлечения экземпляров BillingDetails и всех его подклассов.

Давайте попробуем:
```hql
SELECT bd FROM BillingDetails bd
```
Результат:
```hql
Hibernate: 
    select
        billingdet0_.id as id2_0_,
        billingdet0_.owner as owner3_0_,
        billingdet0_.account as account4_0_,
        billingdet0_.bank_name as bank_nam5_0_,
        billingdet0_.swift as swift6_0_,
        billingdet0_1_.card_number as card_num1_1_,
        billingdet0_1_.exp_month as exp_mont2_1_,
        billingdet0_1_.exp_year as exp_year3_1_,
        billingdet0_.BD_TYPE as BD_TYPE1_0_ 
    from
        BILLING_DETAILS billingdet0_ 
    left outer join
        CREDIT_CARD billingdet0_1_ 
            on billingdet0_.id=billingdet0_1_.ID
```

Как выглядят таблицы:

![1](https://habrastorage.org/r/w1560/getpro/habr/post_images/833/a5d/f27/833a5df2711a38583c0f9de7bb501435.jpg)

![2](https://habrastorage.org/r/w1560/getpro/habr/post_images/ea1/1cb/624/ea11cb624874531a6886de33b560b923.jpg)

Этот прием можно применить и к остальным классам иерархии, но для обширной иерархии он подойдет не слишком хорошо, 
поскольку внешнее соединение в таком случае станет проблемой. Для такой иерархии лучше подойдет стратегия, которая 
немедленно выполнит второй SQL-запрос вместо внешнего соединения.
## Выбор стратегии
Каждая из перечисленных выше стратегий и приемов имеет свои преимущества и недостатки. Общие рекомендации по выбору 
конкретной стратегии будут выглядеть так:
- Стратегию №2 (TABLE_PER_CLASS на основе UNION), если полиморфные запросы и ассоциации не требуются. Если вы редко 
выполняете (или не выполняете вообще) «select bd from BillingDetails bd», и у вас нет классов, ссылающихся на 
BillingDetails, этот вариант будет лучшим (поскольку возможность добавления оптимизированных полиморфных запросов и 
ассоциаций сохранится).
- Стратегию №3 (SINGLE_TABLE) стоит использовать:
  - Только для простых задач. В ситуациях, когда нормализация и ограничение NOT NULL являются критическими – следует 
отдать предпочтение стратегии №4 (JOINED). Имеет смысл задуматься, не стоит ли в данном случае вообще отказаться от 
наследования и заменить его делегированием
  - Если требуются полиморфные запросы и ассоциации, а также динамическое определение конкретного класса во время 
выполнения; при этом подклассы объявляют относительно мало новых полей и основная разница с суперклассом заключается в 
поведении. Ну и вдобавок к этому, Вам предстоит серьезный разговор с администратором БД.
- Стратегия №4 (JOINED) подойдет в случаях, когда требуются полиморфные запросы и ассоциации, но подклассы объявляют 
относительно много новых полей.

Здесь стоит оговориться: решение между JOINED и TABLE_PER_CLASS требует оценки планов выполнения запросов на реальных 
данных, поскольку ширина и глубина иерархии наследования могут сделать стоимость соединений (и, как следствие, 
производительность) неприемлемыми.

Отдельно стоит принять во внимание, что аннотации наследования невозможно применить к интерфейсам.
