# Kotlin и Java
## Оглавление
- [Преимущества Kotlin перед Java 8](#преимущества-kotlin-перед-java-8)
- [Разница между Exception в Java и Kotlin](#разница-между-exception-в-java-и-kotlin)
- [Как перенести статичные методы из Java в Kotlin?](#как-перенести-статичные-методы-из-java-в-kotlin)
- [В какой модификатор преобразуется internal в Java?](#в-какой-модификатор-преобразуется-internal-в-java)
- [Отличия в проверке на равенство == и equals()](#отличия-в-проверке-на-равенство--и-equals)
## Преимущества Kotlin перед Java 8
- Код компактнее на 30-40% - меньше кода = меньше ошибок, выше скорость разработки
- Null Safety - В отличие от Java, в Kotlin по умолчанию все типы являются non-nullable, то есть не могут принимать
значение null. Присвоение или возврат null приведет к ошибке компиляции. Чтобы присвоить переменной значение null, 
в Kotlin необходимо явно пометить эту переменную как nullable (добавив после типа знак вопроса). В Java же при
использовании ссылки на объект с указанным значением null, появляется исключение в виде «NullPointerException».
- Extension function - Kotlin позволяет расширять класс путём добавления нового функционала без необходимости 
наследования от такого класса. Это реализовано с помощью специальных выражений, называемых расширения. Например, вы 
можете написать новые функции для класса из сторонней библиотеки, которую вы не можете изменить. Такие функции можно
вызывать обычным способом, как если бы они были методами исходного класса. Этот механизм называется функцией расширения.
- Data classes - Разработчику на Java приходится писать много стандартного, но часто встречающегося кода (т.н. шаблонный
код или boilerplate). В Kotlin же есть возможность создания специальных классов для определения полей для хранения
данных, конструктора, функций сеттеров и геттеров для каждого поля, и функций Hashcode(), toString() и equals(). Для 
этого достаточно добавить data в определение класса, затем компилятор сделает все сам.
- Синглтоны на уровне языка - В Java все должно объявляться внутри класса. Но в Kotlin все иначе. Компоненты могут
объявляться за пределами класса, и это автоматически делает их статическими. Поэтому нам не требуется ключевое слово
static. В Java статические члены обрабатываются не так, как члены-объекты. В Kotlin static не является ключевым словом и
вместо статических членов используются объекты-компаньоны, позволяющие преодолеть вышеуказанные ограничения. В этом и
заключается преимущество. Даже если члены объектов-компаньонов выглядят как статические члены в других языках, во время
выполнения они все равно остаются членами экземпляров реальных объектов и могут, например, реализовывать интерфейсы.
- Корутины - Kotlin предоставляет возможность создавать дополнительные потоки, однако в нем также существуют т.н. 
корутины (сопрограммы), которые позволяют использовать меньше памяти в сравнении с обычным потоком, т.к. реализованы
они без стека. Корутины же в свою очередь способны выполнять интенсивные и длительные задачи методом приостановления 
выполнения без блокировки потока и его последующего восстановления. Что в дальнейшем позволяет сгенерировать 
асинхронный код без блокирования, который при его выполнении не отличить от синхронного. К тому же, они генерируют
эффектные доп. стили например async или await.
- Умные приведения - В большинстве случаев вам не нужно использовать явные приведения в Kotlin, потому что компилятор
отслеживает is-проверки и явные преобразования для неизменяемых значений и вставляет (безопасно) приведения 
автоматически, там, где они нужны:
```kotlin
fun demo1(x: Any) {
    if (x is String) {
        print(x.length) // x автоматически преобразовывается в String
    }
}

fun demo2(x: Any) {
    // x автоматически преобразовывается в String справа от `||`
    if (x !is String || x.length == 0) return
    
    // x автоматически преобразовывается в String справа от `&&`
    if (x is String && x.length > 0) println(x.length)
}

fun demo3(x: Any) {
    when (x) {
        is Int -> println(x + 1)
        is String -> println(x.length + 1)
        is IntArray -> println(x.sum())
    }
}
```
- Строковые шаблоны - Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный
результат встраивается в строку. Шаблон начинается со знака доллара ($) и состоит либо из простого имени 
(например, переменной) или произвольного выражения в скобках:
```kotlin
val i = 10
println("i = $i") // выведет "i = 10"
val s = "abc"
println("$s.length is ${s.length}") // выведет "abc.length is 3"
```
- Делегирование - механизм, который позволяет перенаправлять вызовы свойств или методов одного класса на другой класс. 
Он предоставляет более чистый и удобный способ реализации повторного использования кода и абстракции, избегая 
необходимости наследования:
```kotlin
interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { println(x) }
}

class Derived(b: Base) : Base by b

fun main() {
    val b = BaseImpl(10)
    Derived(b).print()
}
```
## Разница между Exception в Java и Kotlin
Одним из ключевых отличий между Java и Kotlin является подход к исключениям. В Java есть два типа исключений: checked 
и unchecked.

Checked исключения это те, которые должны быть обработаны в коде, иначе компилятор не позволит коду скомпилироваться.
Unchecked исключения не требуют обработки в коде.

С точки зрения исключений компилятор Kotlin отличается тем, что не различает checked и unchecked исключения.
Все исключения — только unchecked, поэтому нет необходимости отлавливать или объявлять какие-либо исключения (вы
самостоятельно принимаете решение, стоит ли их отлавливать и обрабатывать).

Такой подход был выбран разработчиками Kotlin, чтобы упростить и ускорить процесс разработки, сократив количество
бойлерплейта и улучшив читаемость кода. Однако, это может привести к тому, что некоторые ошибки могут быть упущены при
компиляции и проявиться только во время выполнения программы.
## Как перенести статичные методы из Kotlin в Java?
В Kotlin нет статических методов, для этих целей обычно служит companion object.

Для того чтобы метод из Kotlin был представлен как статический используется аннотация @JvmStatic. Эта аннотация говорит
компилятору Kotlin создать статический метод в байт-коде, что позволяет использовать методы так же, как обычно в Java:
```
// Test.kt
class Test {
    companion object {
        @JvmStatic
        fun add(a: Int, b: Int): Int {
            return a + b
        }
    }
}

// Main.java
public class Main {
    public static void main(String[] args) {
        System.out.println(Test.add(1, 2));
    }
}
```
## В какой модификатор преобразуется internal в Java?
В Java нет эквивалента модификатору доступа internal из Kotlin (default из java ограничивает внутри пакета, а не 
модуля). При компиляции Kotlin-кода в Java-байткод, модификатор доступа internal преобразуется в модификатор public в 
Java.

Таким образом, все члены класса, отмеченные как internal, будут видны из любого места в том же пакете, а также из
любого другого модуля, которому был разрешен доступ к этому модулю. Члены internal классов проходят через искажение
имен, чтобы усложнить случайное использование их из Java и позволить перегрузку для членов с одинаковыми сигнатурами, 
которые не видят друг друга в соответствии с правилами Kotlin.
## Отличия в проверке на равенство == и equals()
1. Проверка на равенство в Java
   - Структурное равенство (значение) — метод equals().
   - Ссылочное равенство — оператор ==: 
     - примитивные типы данных: сравнивает значения переменных
     - ссылочные типы данных (объекты, массивы): сравнивает ссылки

2. Проверка на равенство в Kotlin
   - Структурное равенство (значение) — оператор == (проверка через equals())
   - Ссылочное равенство — оператор ===:
     - примитивные типы данных: сравнивает значения переменных
     - ссылочные типы данных (объекты, массивы): сравнивает ссылки

3. Разница == с Java
   - Структурное равенство (значение) — оператор == в Kotlin это equals() в Java, т.е. в Kotlin строки можно всегда 
   сравнивать через ==.
   - Ссылочное равенство — оператор === в Kotlin это == в Java.
