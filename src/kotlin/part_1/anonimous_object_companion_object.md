# Анонимные классы и объекты, object и companion object
## Оглавление
- [Кратко про анонимные классы и объекты, object и companion object](#кратко-про-анонимные-классы-и-объекты-object-и-companion-object)
- [Объявления объекта (object declaration), object как Singleton](#объявления-объекта-object-declaration-object-как-singleton)
- [Companion object (также Singleton)](#companion-object-также-singleton)
- [Объект-выражение (анонимный объект/object expression)](#объект-выражение-анонимный-объектobject-expression)
- [Разница между анонимным и декларируемым объектов](#разница-между-анонимным-и-декларируемым-объектов)
- [Аннотация JvmStatic](#аннотация-jvmstatic)
## Кратко про анонимные классы и объекты, object и companion object
Анонимный класс — это класс, которые явно не объявлен с помощью class, наследуется от заданного класса или реализует 
заданный интерфейс.

Анонимный класс не всегда является синглтоном. Анонимный класс создается каждый раз при вызове соответствующего
конструктора и используется только в контексте, где был создан. При этом каждый экземпляр анонимного класса имеет
свое уникальное состояние и может отличаться от других экземпляров того же анонимного класса. В Kotlin анонимный класс
создается следующим образом:
```kotlin
fun main() {
    val bird = object : Flyable {
        override fun fly() {
            println("I am flying")
        }

        override fun sing() {
            println("I am singing")
        }
    }
    bird.fly()
    bird.sing()
}

interface Flyable {
    fun fly()
    fun sing()
}
```
Объекты анонимных классов полезны для одноразового использования.

Экземпляры анонимных классов называют анонимными объектами, потому что они объявляются выражением, а не именем.
Анонимный объект начинается с ключевого слова object.
- можно задавать свойства, функции, блоки инициализации;
- можно наследоваться от других классов и реализовывать интерфейсы;
- нельзя создавать конструкторы (как основные, так и вторичные).

Ключевое слово object позволяет одновременно объявить класс и создать его экземпляр (т.е. объект). При этом применять
его можно по-разному:
- object Name — это объявление объекта (оbject declaration), реализация паттерна Singleton;
- companion object — это объект-компаньон внутри класса (также Singleton);
- object — это объект-выражение (анонимный объект/object expression), не Singleton.
## Объявления объекта (object declaration), object как Singleton
Объявляется объект при помощи ключевого слова object, после которого следует имя объекта.

Файл, содержащий только object представляет из себя Singleton, т.е. будет создан только один экземпляр этого класса. 
Пример:
```kotlin
object One {
    val cats = arrayListOf<Cat>()

    fun callCat() {
        for (cat in cats) {
            // ...
        }
    }
}
```
Можно обращаться к методам и свойствам класса через имя объекта:
```kotlin
One.cats.add(Cat(...))
One.callCat()
```
Инициализация объявления объекта потокобезопасна и выполняется при первом доступе (лениво).
## Companion object (также Singleton)
Объекты можно объявлять внутри класса, при этом нет каких-либо ограничений по их количеству. Но только один объект
можно пометить ключевым словом companion object в рамках одного класса.

Синглтон-свойство companion object достигается за счет того, что он создается внутри класса в качестве статического
поля. Он будет инициализирован при первом обращении к нему или при создании первого экземпляра класса, в котором он
объявлен.

Важно отметить, что companion object будет инициализирован первым, а затем уже будет создан экземпляр класса:
```kotlin
class MyClass {
  init {
    // Выполняется всегда после инициализации companion object
  }

  companion object {
    init {
      // Выполняется всегда перед блоком init содержащего класса
    }
  }
}

val myClass = MyClass()
```
Такому объекту можно не указывать свое имя, и обращаться к методам и свойствам объекта через имя содержащего его класса
без явного указания имени объекта.
```kotlin
class SomeClass {
  companion object {
    fun create()
  }
}

val someClass = SomeClass.create()
```
Компилируется в public static final class на Java. Работает подобно ключевому слову static в Java.
## Объект-выражение (анонимный объект/object expression)
Объект-выражение — это выражение, которое "на ходу" создает анонимный объект. Для объекта-выражения не указывается имя.
Если же объекту всё-таки требуется имя, то его можно сохранить в переменной:
```kotlin
val tom = object {
        val name = "Tom"
        var age = 37
        fun sayHello() {
            println("Hi, my name is $name")
        }
    }
    println("Name: ${tom.name}  Age: ${tom.age}")
    tom.sayHello()
```
Анонимные объекты не являются синглтонами. Каждый раз при выполнении объекта-выражения создаётся новый объект.
Анонимный объект является заменой анонимным внутренним классам в Java.
## Разница между анонимным и декларируемым объектов
- анонимный объект (object) инициализируется непосредственно при использовании
- декларированный (объявляемый) объект (object Name) инициализируется лениво, в момент первого к нему доступа
- вспомогательный объект (companion object) инициализируется в момент, когда класс, к которому он относится, загружен и
семантически совпадает со статическим инициализатором Java
## Аннотация JvmStatic
С помощью аннотации @JvmStatic есть возможность объявить методы по настоящему статическими, ее можно добавить как к
методам object, так и к методам companion object:
```kotlin
object ObjectWithStatic {
    @JvmStatic
    fun staticFun(): Int {
        return 5
    }
}
```
В этом случае метод staticFun будет действительно объявлен статическим:
```java
public final class ObjectWithStatic {
   public static final ObjectWithStatic INSTANCE;
 
   @JvmStatic
   public static final int staticFun() {
      return 5;
   }
 
   private ObjectWithStatic() {
      INSTANCE = (ObjectWithStatic) this;
   }
 
   static {
      new ObjectWithStatic();
   }
}
```
