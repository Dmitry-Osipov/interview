# Корутины
## Оглавление
- [Что такое корутины?](#что-такое-корутины)
- [Отличие от потоков](#отличие-от-потоков)
- [Основные ключевые слова](#основные-ключевые-слова)
- [Контекст корутины](#контекст-корутины)
- [Отмена корутин](#отмена-корутин)
- [Преимущество корутин перед потоками](#преимущество-корутин-перед-потоками)
- [Когда использовать корутины](#когда-использовать-корутины)
- [Исключения в launch и async](#исключения-в-launch-и-async)
## Что такое корутины?
Корутина — это "вычислительная единица", которую можно приостанавливать и возобновлять в любой момент. Главное отличие 
корутины от обычного потока в том, что корутина не блокирует поток, на котором она выполняется, а приостанавливается,
когда требуется подождать результат асинхронной операции (например, запрос в сеть или чтение из базы данных), и
возобновляется позже, когда результат готов. Это делает корутины легковесными по сравнению с традиционными потоками,
которые в случае ожидания блокируют поток операционной системы.
## Отличие от потоков
- Лёгкость: Потоки (threads) операционной системы — это достаточно "тяжёлая" конструкция. Их создание, переключение
между ними и управление ими связано с накладными расходами. Корутины же — это лёгкие задачи, которые выполняются внутри
потоков. Одна корутина занимает гораздо меньше ресурсов по сравнению с потоком. Ты можешь запустить десятки тысяч 
корутин в одном потоке, тогда как потоков ОС может быть одновременно запущено всего несколько тысяч.
- Асинхронное выполнение: Корутины предоставляют удобный способ писать асинхронный код последовательно, что сильно
упрощает разработку. Это позволяет избегать большого количества коллбеков и вложенных вызовов, которые могут затруднить
чтение кода. Код с корутинами выглядит более линейно и понятно.
## Основные ключевые слова
### Suspend
Ключевое слово suspend используется для того, чтобы объявить функцию как приостанавливаемую. Это значит, что функция
может приостановить своё выполнение без блокировки потока, на котором она выполняется, и возобновить выполнение позже.
При этом важно отметить, что suspend-функция не выполняется в отдельном потоке — она может выполняться на том же
потоке, где была вызвана, просто приостанавливается при необходимости.
```kotlin
suspend fun fetchData(): String {
    // имитируем длительную операцию (например, запрос в сеть)
    delay(1000)
    return "Data fetched"
}
```
### Launch
launch используется для запуска новой корутины. Эта корутина будет выполняться асинхронно по отношению к остальному 
коду, и её выполнение не блокирует текущий поток.
```kotlin
fun main() = runBlocking {
    launch {
        val data = fetchData()
        println(data)
    }
    println("Корутина запущена")
}
```
### Async и Await
async запускает корутину, которая возвращает результат. Она похожа на launch, но используется для вычислений, результат 
которых нужно вернуть. Для получения результата используется await.
```kotlin
fun main() = runBlocking {
    val result = async {
        fetchData()
    }
    println("Ждём результат...")
    println("Результат: ${result.await()}")
}
```
## Контекст корутины
Каждая корутина выполняется в определённом контексте корутины (CoroutineContext), который управляет её поведением. 
Контекст может определять диспетчер (dispatcher) - управляет, на каком потоке или пуле потоков будет выполняться
корутина. Kotlin предоставляет несколько стандартных диспетчеров:
- Dispatchers.Main — для работы с UI-потоком (актуально для Android).
- Dispatchers.IO — для операций ввода-вывода (например, работа с сетью или чтение/запись файлов).
- Dispatchers.Default — для тяжёлых вычислений, которые требуют высокопроизводительных потоков.
- Dispatchers.Unconfined — корутина начинает выполняться на том потоке, где была вызвана, а затем может быть
перенесена на другой.
```kotlin
fun main() = runBlocking {
    launch(Dispatchers.IO) {
        println("Выполнение в пуле потоков IO")
    }
    println("Завершение main")
}
```
## Отмена корутин
Корутины можно отменять. Это особенно полезно, если задача больше не актуальна, и её выполнение нужно прервать.
```kotlin
fun main() = runBlocking {
    val job = launch {
        repeat(1000) { i ->
            println("Работаем над задачей $i ...")
            delay(500)
        }
    }
    delay(2000)  // даём поработать корутине 2 секунды
    println("Отменяем корутину")
    job.cancel()  // отменяем корутину
    job.join()    // ждём завершения корутины
    println("Коррутина завершена")
}
```
## Преимущество корутин перед потоками
- Лёгкость: Тысячи корутин могут быть выполнены в одном потоке, тогда как с потоками это было бы невозможно из-за 
ограничения ресурсов.
- Асинхронность без блокировки: Корутины позволяют писать асинхронный код последовательно, без сложных коллбеков и
вложений.
- Управление потоками: Корутины обеспечивают гибкое управление потоками через диспетчеры, позволяя распределять задачи
между разными потоками в зависимости от типа операции.
## Когда использовать корутины
- Асинхронные операции: Когда нужно выполнять сетевые запросы, работу с базой данных или другие длительные операции без
блокировки основного потока.
- UI-приложения: Например, на Android, корутины позволяют выполнять длительные задачи (например, запросы в интернет) в
фоновом режиме и обновлять интерфейс по завершении без блокировки UI-потока.
- Высоконагруженные системы: Когда важно управлять большими объемами параллельных задач без создания огромного
количества потоков и затрат на их управление.
## Исключения в launch и async
### launch и исключения
Функция launch используется для запуска корутины без возврата результата. Она возвращает объект типа Job, который
представляет выполнение задачи. В случае возникновения исключения в корутине, запущенной через launch, это исключение 
автоматически пробрасывается на уровень корневого контекста, в котором была запущена корутина. Это означает, что если 
в корутине произойдет ошибка, она немедленно завершится, и исключение будет проброшено наверх.
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        println("Корутина начала выполнение")
        throw RuntimeException("Ошибка в launch корутине")
    }
    
    job.join() // Ждем завершения корутины
    println("Корутина завершена")
}
```
Особенности исключений в launch:
1) Исключения необработанные: Если исключение не поймано внутри тела корутины, оно будет проброшено и завершит
выполнение всей корутины.
2) Корневой контекст: Исключение будет передано в корневой контекст (например, в runBlocking), если его не поймали в
теле самой корутины.
3) Отмена корутины: Исключение приведет к отмене всех связанных дочерних корутин, если они запущены в том же контексте.

Чтобы поймать исключение в корутине launch, его можно обернуть в блок try-catch:
```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch {
        try {
            println("Корутина начала выполнение")
            throw RuntimeException("Ошибка в launch корутине")
        } catch (e: Exception) {
            println("Исключение поймано: ${e.message}")
        }
    }
    
    job.join()
    println("Корутина завершена")
}
```
### async и исключения
Функция async используется для запуска корутины, которая возвращает результат в виде объекта Deferred. В отличие от 
launch, она предназначена для выполнения параллельных задач и получения результата. Исключения в async корутинах
работают иначе: они не выбрасываются сразу, как в launch, а сохраняются и пробрасываются только тогда, когда вызывается
метод await().

Пример с async:
```kotlin
fun main() = runBlocking {
    val deferred = async {
        println("Корутина начала выполнение")
        throw RuntimeException("Ошибка в async корутине") // Тут будет выброшено исключение
    }

    try {
        deferred.await() // Тут какая-то обработка исключения, но при этом само исключение всё равно будет выброшено
    } catch (e: Exception) {
        println("Исключение поймано: ${e.message}")
    }
}
```
Особенности исключений в async:
1) Исключение не выбрасывается сразу при выполнении корутины, а сохраняется до момента вызова await() (нет, всё равно
выбрасывается, даже если нет вызова метода)
2) Необработанные исключения: Если исключение не обработано через await(), оно будет выброшено в момент обращения к 
результату через await(). (нет, всё равно выбрасывается, даже если нет вызова метода)
3) Отмена корутины: Если при вызове await() было выброшено исключение, корутина также будет отменена.
### Сравнение launch и async в контексте исключений
| Характеристика       | launch                         | async                                   |
|----------------------|--------------------------------|-----------------------------------------|
| Возвращает результат | Job                            | Deferred<T>                             |
| Обработка исключений | Исключение выбрасывается сразу | Исключение выбрасывается при await(нет) |
| Отмена корутины      | Исключение отменяет корутину   | Отменяет корутину при await()           |
### Практическое применение исключений в launch и async
- launch используется, когда нужно запустить корутину, которая ничего не возвращает, но при этом нужно следить за тем,
что она завершилась успешно или с ошибкой.
- async используется, когда корутина должна вернуть результат, и важно учитывать, что исключение может произойти при
попытке получить этот результат с помощью await().
