# Диспетчеры
## Оглавление
- [Что такое диспетчеры?](#что-такое-диспетчеры)
- [Основные виды](#основные-виды)
- [Как диспетчеры влияют на выполнение корутин?](#как-диспетчеры-влияют-на-выполнение-корутин)
- [Когда использовать какой диспетчер?](#когда-использовать-какой-диспетчер)
- [Обобщённое управление с потоками с withContext](#обобщённое-управление-с-потоками-с-withcontext)
- [Почему правильное использование диспетчеров важно?](#почему-правильное-использование-диспетчеров-важно)
## Что такое диспетчеры?
Диспетчеры (Dispatchers) в Kotlin — это механизм управления тем, на каком потоке или пуле потоков будет выполняться 
корутина. Диспетчеры играют важную роль в асинхронном программировании, так как позволяют эффективно распределять
задачи, управлять потоками и переключаться между контекстами выполнения.
## Основные виды
### Dispatchers.Default
Этот диспетчер используется по умолчанию для запуска корутин, если явно не указан другой диспетчер. Он предназначен для
выполнения CPU-интенсивных задач, таких как обработка данных, вычисления или выполнение алгоритмов. Dispatchers.Default
использует пул потоков с количеством потоков, равным количеству ядер процессора.
- Когда использовать: когда нужно выполнить вычислительные задачи (например, сортировка большого списка, сложные
вычисления).
- Пул потоков: размер пула равен числу ядер процессора.
```kotlin
launch(Dispatchers.Default) {
    // Вычислительная задача
    val result = (1..1_000_000).sum()
    println(result)
}
```
### Dispatchers.IO
Этот диспетчер используется для задач ввода-вывода (I/O), таких как работа с сетью, чтение/запись в файлы или запросы в
базу данных. Он оптимизирован для операций, которые часто блокируют поток на долгое время. Пул потоков Dispatchers.IO
может динамически увеличиваться в зависимости от нагрузки.
- Когда использовать: когда задачи связаны с вводом-выводом (например, запросы к базе данных, сетевые запросы).
- Пул потоков: пул адаптивен и может увеличиваться в зависимости от количества задач, связанных с вводом-выводом.
```kotlin
launch(Dispatchers.IO) {
    // Чтение файла
    val fileContent = File("data.txt").readText()
    println(fileContent)
}
```
### Dispatchers.Main
Этот диспетчер используется для выполнения корутин на главном потоке, который обрабатывает пользовательский интерфейс 
(UI) в приложениях Android или JavaFX. Он необходим для выполнения задач, связанных с обновлением UI, так как доступ к
элементам пользовательского интерфейса должен происходить с главного потока.
- Когда использовать: для обновления пользовательского интерфейса (например, в Android или JavaFX).
- Пул потоков: главный поток (UI-поток).
```kotlin
// Необходимо подключить стороннюю библиотеку: Module with the Main dispatcher is missing. Add dependency providing the
// Main dispatcher, e.g. 'kotlinx-coroutines-android' and ensure it has the same version as 'kotlinx-coroutines-core'
launch(Dispatchers.Main) {
    // Обновление UI в Android
    textView.text = "Hello, Kotlin!"
}
```
### Dispatchers.Unconfined
Этот диспетчер не привязывает корутину к какому-либо конкретному потоку или пулу потоков. В начале выполнения корутина
выполняется на том потоке, на котором была запущена, но затем может переключаться на другие потоки в зависимости от
вызванных функций приостановки. Dispatchers.Unconfined обычно используется для быстрых, простых задач, которым не нужно
закрепление за конкретным потоком.
- Когда использовать: для лёгких задач, которые не требуют потока для выполнения.
- Пул потоков: стартует на текущем потоке, а затем может быть переключён на другой поток.
```kotlin
launch(Dispatchers.Unconfined) {
    println("Запущено на потоке: ${Thread.currentThread().name}")
    delay(1000)
    println("После задержки на потоке: ${Thread.currentThread().name}")
}
```
### newSingleThreadContext и newFixedThreadPoolContext
Эти диспетчеры позволяют создать корутину с выполнением на одном потоке (newSingleThreadContext) или на пуле с 
фиксированным числом потоков (newFixedThreadPoolContext). Они используются в редких случаях, когда вам нужно обеспечить
выполнение задач строго на одном потоке (например, для задач, требующих синхронизации).
- Когда использовать: когда необходим фиксированный поток для критических секций или специфических задач.
- Пул потоков: один поток для newSingleThreadContext, фиксированный размер для newFixedThreadPoolContext.
```kotlin
val singleThreadContext = newSingleThreadContext("MyThread")

launch(singleThreadContext) {
    println("Запущено на потоке: ${Thread.currentThread().name}")
}
```
## Как диспетчеры влияют на выполнение корутин?
Диспетчеры управляют контекстом выполнения корутины, указывая, где и как должна выполняться задача. При использовании
диспетчеров происходит следующее:
1) Разделение задач: тяжелые вычислительные задачи отправляются на Dispatchers.Default, задачи ввода-вывода — на
Dispatchers.IO, а обновление UI — на Dispatchers.Main. Это позволяет не блокировать главный поток и обеспечивает
высокую отзывчивость приложения.
2) Переключение контекстов: вы можете переключаться между диспетчерами внутри одной корутины для эффективного
выполнения разных этапов задачи (например, загрузка данных с сети на Dispatchers.IO и обновление UI
на Dispatchers.Main).

Пример переключения диспетчеров:
```kotlin
launch(Dispatchers.Main) {
    // Ожидание данных на IO-диспетчере
    val data = withContext(Dispatchers.IO) {
        loadDataFromNetwork()
    }
    // Обновление UI на Main-диспетчере
    textView.text = data
}
```
## Когда использовать какой диспетчер?
- CPU-интенсивные задачи: Dispatchers.Default.
- Ввод-вывод (I/O) задачи: Dispatchers.IO.
- Работа с UI: Dispatchers.Main.
- Лёгкие и быстрые задачи без закрепления за потоком: Dispatchers.Unconfined.
## Обобщённое управление с потоками с withContext
Часто в корутинах для эффективного выполнения задачи нужно переключаться между диспетчерами, например, для выполнения
сетевого запроса на Dispatchers.IO и последующего обновления UI на Dispatchers.Main. Для этого в Kotlin есть функция
withContext, которая позволяет временно изменить диспетчер в рамках одной корутины.
```kotlin
val result = withContext(Dispatchers.IO) {
    // Сетевой запрос или чтение файла
    loadDataFromNetwork()
}

withContext(Dispatchers.Main) {
    // Обновление UI на основе полученных данных
    textView.text = result
}
```
## Почему правильное использование диспетчеров важно?
1) Производительность: использование Dispatchers.IO для операций ввода-вывода предотвращает блокировку потоков, что
улучшает отзывчивость приложения.
2) Управление потоками: распределение задач по правильным пулам потоков (например, вычисления на Dispatchers.Default,
а операции с сетью на Dispatchers.IO) помогает избежать перегрузки потоков.
3) Безопасность: в приложениях с пользовательским интерфейсом (например, Android) операции с UI должны выполняться на
главном потоке. Использование Dispatchers.Main гарантирует, что изменения UI будут происходить безопасно.
