# Access modifiers. Properties. Delegates. Constructors. Init block
## Оглавление
- [Модификаторы доступа](#модификаторы-доступа)
- [Разница между val, var, const val](#разница-между-val-var-const-val)
- [Свойства, методы get и set](#свойства-методы-get-и-set)
- [В чём отличие field от property?](#в-чём-отличие-field-от-property)
- [Отложенная и ленивая инициализация свойств (lateinit и by lazy)](#отложенная-и-ленивая-инициализация-свойств-lateinit-и-by-lazy)
- [Что такое делегированные свойства?](#что-такое-делегированные-свойства)
- [Как реализовать кастомный делегат?](#как-реализовать-кастомный-делегат)
- [Конструкторы](#конструкторы)
- [Блок инициализации](#блок-инициализации)
## Модификаторы доступа
Классы, объекты, интерфейсы, конструкторы, функции, свойства и их сеттеры могут иметь модификаторы доступа. Геттеры 
всегда имеют ту же видимость, что и свойства, к которым они относятся. Модификаторы доступа — это ключевые слова, с 
помощью которых можно задать область действия данных. Они позволяют регулировать уровень доступа к различным частям 
кода. Локальные переменные, функции и классы не могут иметь модификаторов доступа.

В Kotlin есть четыре модификатора доступа: private, protected, internal и public. Если модификатор явно не указан, то
присваивается значение по умолчанию — public:
- Private — доступ к членам класса только в пределах самого класса. То есть, поля и методы с модификатором private
недоступны из других классов и даже из наследников.
- Protected — доступ к членам класса только в пределах класса и его наследников. То есть, поля и методы с модификатором
protected доступны из класса и его наследников, но не из других классов.
- Internal — доступ к членам модуля (module). Модуль — это набор файлов, компилирующихся вместе, поэтому все классы,
объявленные внутри модуля, могут иметь доступ к членам с модификатором internal.
- Public — не ограничивает доступ к членам класса. Поля и методы с модификатором public доступны из любого места
программы, включая другие модули.
## Разница между val, var, const val
1) var — это изменяемая переменная. После инициализации мы можем изменять данные, хранящиеся в переменной. 
2) val — константа времени выполнения, т.е. значение можно назначить во время выполнения программы. 
3) const val — константа времени компиляции, т.к. значения константам присваивается при компиляции (в момент, когда 
программа компилируется).

В отличие от val, значение const val должно быть известно во время компиляции.

Особенности const val:
- могут получать значение только базовых типов: Int, Double, Float, Long, Short, Byte, Char, String, Boolean
- объявляются в глобальной области видимости, то есть за пределами функции main() или любой другой функции
- нет пользовательского геттера

Как стоит объявлять свои константы в Kotlin — при помощи companion object или вне класса?

На самом деле оба эти подхода приемлемы. Однако, использование companion object может быть излишним: компилятор Kotlin
преобразует companion object во вложенный класс. Слишком много кода для простой константы.

Если вам не требуется поведение, специфичное для companion object, объявляйте константы вне класса, так как это будет
способствовать более эффективному байт-коду. Да и сам синтаксис объявления констант вне класса более чистый и 
читабельный.
## Свойства, методы get и set
Свойства класса — это переменные, которые хранят состояние объекта класса. Как и любая переменная, свойство может иметь 
тип, имя и значение.

В классе можно объявить свойства с помощью ключевого слова var или val. Свойства, объявленные с var, могут быть 
изменены после их инициализации, а свойства, объявленные с val, только для чтения.
```kotlin
class Person {
    var name: String = ""
    val age: Int = 0
}
```
При создании своего класса мы хотим сами управлять его свойствами, контролируя то, какие данные могут быть
предоставлены или перезаписаны. С этой целью создаются get и set методы (геттеры и сеттеры). Цель get-метода — вернуть
значение, а set-метода — записать полученное значение в свойство класса.
```kotlin
var name: String = ""
    get() = field.uppercase()
    set(value) {
        field = "Name: $value"
    }
```
В данном примере свойство name имеет тип String и начальное значение пустой строки. Геттер возвращает значение свойства,
преобразованное к верхнему регистру. Сеттер устанавливает значение свойства с добавлением префикса "Name: " перед 
переданным значением. Слово field используется для обращения к текущему значению свойства.

Если get и set методы не были созданы вручную, то для таких свойств Kotlin незаметно сам их генерирует. При этом для
свойства, объявленного с val, генерируется get-метод, а для свойства, объявленного с var — и get, и set методы.
## В чём отличие field от property?
### Field
Поле — это переменная, которая хранится внутри объекта (или класса). Поля могут быть как экземплярными (относятся к 
конкретному объекту), так и статическими (принадлежат классу и общие для всех его экземпляров). Поля могут иметь 
различные модификаторы доступа (private, protected, public), которые определяют, как и откуда к ним можно обращаться.
```kotlin
class Person {
    private val name: String // Это поле
    var age: Int = 0 // Это тоже поле, но с открытым доступом

    constructor(name: String) {
        this.name = name
    }
}
```
Важно: Поля обычно не должны напрямую изменяться извне. Вместо этого рекомендуется использовать свойства.
### Property
Свойство — это абстракция, представляющая поле с его геттерами и сеттерами. Свойства предоставляют удобный интерфейс
для доступа к полям, а также могут содержать дополнительную логику при чтении или записи значения. В Kotlin свойства
создаются с помощью ключевых слов val (для неизменяемых свойств) и var (для изменяемых свойств). Каждый раз, когда вы 
объявляете свойство, автоматически создается поле, которое хранит значение свойства.
```kotlin
class Person {
    var name: String = "John" // Это свойство с полем
        get() = field.uppercase() // Переопределенный геттер
        set(value) { field = value.trim() } // Переопределенный сеттер

    var age: Int = 0 // Свойство без дополнительной логики
}
```
### Ключевые различия
1) Уровень абстракции:
   - Field — это низкоуровневая реализация данных, которые хранятся в классе.
   - Property — это высокоуровневая абстракция, которая включает в себя логику доступа к данным (геттеры и сеттеры).
2) Доступ к данным:
   - Поля обычно скрыты и не должны использоваться напрямую извне класса.
   - Свойства предоставляют публичный интерфейс для работы с полями, позволяя контролировать доступ и модификацию
   данных.
3) Поддержка логики:
   - Поля не могут содержать бизнес-логику.
   - Свойства могут содержать логику в геттерах и сеттерах, позволяя обрабатывать значение перед его установкой или
   возвратом.
## Отложенная и ленивая инициализация свойств (lateinit и by lazy)
Отложенная и ленивая инициализация свойств — это механизмы, которые позволяют отложить инициализацию переменных до
момента их первого использования. Оба варианта позволяют экономить ресурсы, т.к. избегают необходимости создания
объектов при инициализации класса.
1) lateinit - модификатор говорит о том, что данная переменная будет инициализирована позже. При этом инициализировать 
свойство можно из любого места, откуда она видна. Правила использования:
   - может использоваться только с var-свойствами класса
   - может быть применён только к свойствам, объявленным внутри тела класса (но не в основном конструкторе), а также к
   переменным на верхнем уровне и локальным переменным
   - свойства могут иметь любой тип, кроме java-примитивов (Int, Double, Long и т.д.)
   - свойства не могут быть nullable
   - свойства не могут быть проинициализированы сразу при их объявлении
   - свойства должны быть инициализированы до первого обращения к ним, иначе будет выброшено исключение 
   UninitializedPropertyAccessException
   - нельзя использовать для переменных, определённых внутри локальных областей видимости
   - у свойства не должно быть пользовательских геттеров и сеттеров
2) by lazy - подход, при котором объект инициализируется только при необходимости, а не сразу после создания.

Когда свойство объявляется с использованием делегата lazy, оно не инициализируется сразу, а только тогда, когда к нему
происходит первое обращение. При этом инициализация выполняется единожды, и в дальнейшем значение свойства сохраняется
для всех последующих обращений к нему. Таким образом, ленивая инициализация позволяет оптимизировать использование
ресурсов приложения, не инициализируя объекты, которые не понадобятся в ходе выполнения программы.

При использовании ленивой инициализации свойств с помощью by lazy в Kotlin, создается объект типа Lazy<T>, где T — это 
тип свойства, и этот объект используется для хранения значения свойства.

Когда код доходит до места, где используется свойство, вызывается метод getValue() этого объекта Lazy<T>. Если значение
свойства еще не было проинициализировано, то вызывается лямбда-выражение, переданное в lazy { }, и ее результат
используется для инициализации свойства. Значение сохраняется в объекте Lazy<T> и возвращается как результат метода
getValue(). Если значение уже было проинициализировано, то просто возвращается сохраненное значение. Например, если у
нас есть свойство:
```kotlin
val myProperty: Int by lazy { computeValue() }  // by lazy поддерживает только val
```
то при первом обращении к свойству myProperty будет выполнена функция computeValue(), а результат будет сохранен. При
последующих обращениях к свойству будет возвращено сохраненное значение.
3) Сравнение ленивой и отложенной инициализации:
- Ленивая инициализация является одним из Delegate. Отложенная инициализация требует использования модификатора свойства
- Ленивая инициализация применяется только к val. Отложенная инициализация применяется только к var
- У нас может быть ленивое свойство примитивного типа. lateinit применяется только к ссылочным типам

Самое главное, когда мы реализуем свойство как ленивый делегат, мы фактически присваиваем ему своего рода значение. 
Вместо фактического значения мы помещаем туда функцию для его вычисления, когда оно понадобится.

С другой стороны, когда мы объявляем свойство как lateinit, мы просто отключаем одну из проверок компилятора, которая 
гарантирует, что программа не обращается ни к одной переменной до того, как она получит значение. Вместо этого мы 
обещаем сделать эту проверку сами.
## Что такое делегированные свойства?
Делегированные свойства (Delegated properties) — это свойства, которые не хранят своё значение напрямую, а делегируют
это значение другому объекту, который реализует интерфейс Delegate. При доступе к свойству, его значение запрашивается
у делегата, который может выполнить какую-то дополнительную логику, а затем вернуть требуемое значение. Пример:
```kotlin
class Person(name: String) {
   var name: String by lazy { println("Hello everyone"); "Alice" }
}
```
Ключевое слово by используется для обозначения свойств, методы чтения и записи которых реализованы другим объектом,
который называют делегатом.

Синтаксис выглядит так: val/var <имя свойства>: <Тип> by <выражение>. Выражение после by — делегат, потому что
обращения get(), set() к свойству будут делегированы его методам getValue() и setValue(). Делегат не обязан
реализовывать какой-то интерфейс, достаточно, чтобы у него были метод getValue() (и setValue() для var'ов) с
определённой сигнатурой.

В Kotlin существуют несколько встроенных делегатов для работы с делегированными свойствами:
- lazy() — позволяет создавать лениво инициализированные свойства
- observable() — позволяет реагировать на изменения свойства
- vetoable() — позволяет отклонять изменения значения свойства на основе заданного условия
- notNull() — гарантирует, что свойство не будет иметь значение null
- map() — позволяет хранить значения свойств в словаре (Map)

Кроме того, в Kotlin можно создавать свои собственные делегаты, реализуя интерфейс ReadOnlyProperty или
ReadWriteProperty. Это дает возможность создавать кастомные поведения для свойств, например, кеширование значений или
логирование операций чтения/записи.
## Как реализовать кастомный делегат?
Чтобы написать кастомный делегат, нужно определить класс, который реализует интерфейс ReadOnlyProperty для делегата val 
или ReadWriteProperty для делегата var.

Классы, реализующие ReadOnlyProperty и ReadWriteProperty, содержат два метода:
- getValue(thisRef: T, property: KProperty<*>): R, который должен возвращать значение свойства.
- setValue(thisRef: T, property: KProperty<*>, value: R), который должен устанавливать значение свойства.

Например, рассмотрим создание кастомного делегата для логирования изменения значения свойства:
```kotlin
class LoggingDelegate<T>(private var value: T) : ReadWriteProperty<Any?, T> {
   override fun getValue(thisRef: Any?, property: KProperty<*>): T {
      println("Getting value for '${property.name}' = $value")
      return value
   }

   override fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
      println("Setting value for '${property.name}' to $value")
      this.value = value
   }
}
```
Здесь мы определяем класс LoggingDelegate, который реализует интерфейс ReadWriteProperty. Метод getValue выводит в 
консоль текущее значение свойства и возвращает его, а метод setValue выводит новое значение свойства в консоль и
сохраняет его в переменной value.

Затем мы можем использовать наш кастомный делегат следующим образом:
```kotlin
class MyClass {
    var myProperty: Int by LoggingDelegate(0)
}

fun main() {
    val obj = MyClass()
    obj.myProperty = 42 // Setting value of myProperty to 42
    println(obj.myProperty) // Getting value of myProperty: 42
}
```
Здесь мы создаем экземпляр класса MyClass, который содержит свойство myProperty, использующее наш кастомный делегат
LoggingDelegate. При установке значения свойства или получении его значения будут вызываться соответствующие методы 
нашего делегата, и мы увидим соответствующие сообщения в консоли.
## Конструкторы
Свойств у класса может быть столько, сколько ему нужно. Но все они должны быть инициализированы при создании экземпляра
этого класса. Поэтому для удобства был придуман конструктор — специальный блок кода, который вызывается при создании
экземпляра класса. Ему передаются необходимые значения, которые потом используются для инициализации свойств.

Класс в Kotlin может иметь основной конструктор (primary) и один или более вторичных конструкторов (secondary). У класса
может и не быть конструктора, но Kotlin всё равно автоматически сгенерирует основной конструктор по умолчанию (без
параметров).
1) Основной конструктор

Объявляется он сразу после имени класса и состоит из ключевого слова constructor и круглых скобок:
```kotlin
class Person constructor(name: String, age: Int) {
   val name = name
   var age = age
}
```
Можно обойтись и без ключевого слова constructor при условии, что нет аннотаций или модификаторов доступа.
```kotlin
class Person(name: String, age: Int) {
   val name = name
   var age = age
}
```
Параметры, переданные в конструктор, можно использовать для инициализации свойств, объявленных в теле класса.
```kotlin
class Person(name: String, age: Int) {
    val name = name
    var age = age
}
```
А можно упростить еще больше и из параметров конструктора сделать свойства класса. Для этого перед именем параметра 
нужно указать ключевое слово val (только для чтения) или var (для чтения и редактирования).
```kotlin
class Person(val name: String, var age: Int)
```
При этом любому из свойств можно присвоить значение по умолчанию. Тогда при создании экземпляра класса для этого 
свойства значение можно либо не указывать, либо указать, если оно отличается от стандартного.
```kotlin
class Person(val name: String, var age: Int = 30)
...
val adam = Person("Adam")
val alice = Person("Alice", 25)
println("${adam.name}, ${adam.age}")      // Adam, 30
println("${alice.name}, ${alice.age}")    // Alice, 25
```
У класса может быть суперкласс. Тогда его основной конструктор должен инициализировать свойства, унаследованные от
суперкласса.
```kotlin
open class Base(p: Int)

class Person(val name: String, var age: Int = 30, val p: Int) : Base(p)
...
val adam = Person("Adam", 30, 1000)
println(adam.p)                      // 1000
```
Конструктор можно сделать приватным. Тогда никто и ничто не сможет создать экземпляр этого класса.
```kotlin
class Person private constructor(val name: String, var age: Int)
...
val adam = Person("Adam", 30)  // вылетит ошибка
```
2) Вторичный конструктор

Также известен как вспомогательный, дополнительный, secondary конструктор. Вторичный конструктор используется в том
случае, когда необходимо определить альтернативный способ создания класса. В Kotlin это применяется редко, так как 
обычно основного конструктора бывает достаточно благодаря возможности добавлять значения по умолчанию и использовать
именованные аргументы.

Объявляется вторичный конструктор внутри тела класса при помощи ключевого слова constructor.
```kotlin
class Person {
  constructor(id: Int) {
    ...
  }
}
```
При этом если у класса есть основной конструктор, то все вторичные конструкторы обязательно должны явно или косвенно 
его вызывать. Подразумевается, что либо вторичный конструктор сам вызывает основной конструктор, либо сначала вызывает 
другой вторичный конструктор, который в свою очередь обращается к основному конструктору. Обращение к основному 
конструктору осуществляется при помощи ключевого слова this.
```kotlin
class Person(val name: String, var age: Int, var salary: Int) {
    constructor(name: String, age: Int) : this(name, age, 5000) {
        ...
    }
}
```
Если основного конструктора нет, то и обращаться к нему не надо.

Во вторичном конструкторе нельзя объявлять свойства класса. Все передаваемые ему параметры можно использовать либо для 
передачи основному конструктору, либо для инициализации свойств, объявленных в теле класса.
```kotlin
class Person(val name: String, var age: Int) {
    var id: Int = 0

    constructor(name: String, age: Int, id: Int) : this(name, age) {
        this.id = id
    }
}
```
Также во вторичный конструктор можно добавить какую-либо логику.
```kotlin
class Person(val name: String, var age: Int) {
    var id: Int = 0

    constructor(name: String, age: Int, id: Int) : this(name, age) {
        if (id > 0) this.id = id * 2
    }
}
```
Если у класса есть суперкласс, но нет основного конструктора, то каждый вторичный конструктор должен обращаться к
конструктору суперкласса при помощи ключевого слова super.
```kotlin
open class Base(val p: Int)

class Person : Base {
    constructor(name: String, age: Int, p: Int) : super(p)
}
...
val adam = Person("Adam", 30, 1)
println(adam.p)                   // 1
```
## Блок инициализации
Основной конструктор не может в себе содержать какую-либо логику по инициализации свойств (исполняемый код). Он
предназначен исключительно для объявления свойств и присвоения им полученных значений. Поэтому вся логика может быть
помещена в блок инициализации — блок кода, обязательно выполняемый при создании объекта независимо от того, с помощью
какого конструктора этот объект создаётся. Помечается он словом init.
```kotlin
class Person(val name: String, var age: Int) {
    var id: Int = 0

    // require выдает ошибку с указанным текстом, если условие в левой части false
    init {
        require(name.isNotBlank(), { "У человека должно быть имя!" })
        require(age > -1, { "Возраст не может быть отрицательным." })
    }

    constructor(name: String, age: Int, id: Int) : this(name, age) {
        if (id > 0) this.id = id * 2
    }
}
```
По сути блок инициализации — это способ настроить переменные или значения, а также проверить, что были переданы
допустимые параметры. Код в блоке инициализации выполняется сразу после создания экземпляра класса, т.е. сразу после
вызова основного конструктора. В классе может быть один или несколько блоков инициализации и выполняться они будут
последовательно.
```kotlin
class Person(val name: String, var age: Int) {
    // сначала вызывается основной конструктор и создаются свойства класса
    // далее вызывается первый блок инициализации
    init {
        ...
    }

    // после первого вызывается второй блок инициализации
    init {
        ...
    }

    // и т.д.
}
```
Блок инициализации может быть добавлен, даже если у класса нет основного конструктора. В этом случае его код будет
выполнен раньше кода вторичных конструкторов.

![Последовательность блоков при создании объекта](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ddf/a48/b2a/ddfa48b2a21552e3a32c14940faf7d2a.png)
