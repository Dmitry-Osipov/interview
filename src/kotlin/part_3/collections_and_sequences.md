# Collections and Sequences
## Оглавление
- [Какие коллекции есть в Kotlin?](#какие-коллекции-есть-в-kotlin)
- [List](#list)
- [Set](#set)
- [Map](#map)
- [Какая из коллекций не является имплементацией Collection?](#какая-из-коллекций-не-является-имплементацией-collection)
- [Sequences и их отличия от коллекций](#sequences-и-их-отличия-от-коллекций)
- [Промежуточные и терминальные операции в Sequences](#промежуточные-и-терминальные-операции-в-sequences)
## Какие коллекции есть в Kotlin?
Коллекция — это объект, содержащий в себе набор значений одного или различных типов, а также позволяющий к этим 
значениям обращаться и извлекать. Другими словами — это контейнер, в который вы можете помещать то, что вам нужно, а 
затем каким-либо образом с ним взаимодействовать. В Kotlin есть три типа коллекций:
- List (список). Упорядоченная коллекция, в которой к элементам можно обращаться по их индексам. Идентичные элементы
(дубликаты) могут встречаться в списке более одного раза. Примером списка является предложение: это группа слов, их
порядок важен, и они могут повторяться.
- Set (множество/набор). Неупорядоченная коллекция без повторяющихся значений. Примером множества является алфавит.
- Map (словарь/ассоциативный список). Набор из пар "ключ-значение". Ключи уникальны и каждый из них соответствует ровно 
одному значению. В коллекции могут присутствовать повторяющиеся значения, но не повторяющиеся ключи. Пример — ID
сотрудников и их должностей. Map не является наследником интерфейса Collection.

Два типа интерфейсов, на основе которых создаются коллекции:
1) Неизменяемый (read-only) — дают доступ только для чтения (Set, List, Map, Collection).
2) Изменяемый (mutable) — расширяет предыдущий интерфейс и дополнительно даёт доступ к операциям добавления, удаления
и обновления элементов коллекции (MutableSet, MutableList, MutableMap, MutableCollection).

![Иерархия коллекций](https://habrastorage.org/r/w1560/getpro/habr/upload_files/471/232/032/4712320326f3181bc5e9ef0ea07a943f.png)
## List
Список — это упорядоченная коллекция. Каждое значение, помещённое в List, называется элементом, к которому можно
обращаться по индексу. Индексы начинаются с "0" и заканчиваются индексом последнего элемента в списке — (list.size - 1).
Список может содержать сколько угодно одинаковых элементов — дублей (в том числе null).
```kotlin
val trees = listOf("Сосна", "Берёза", "Дуб") // неизменяемый список
trees.add("Ясень") // ошибка

val mutableTrees = mutableListOf("Сосна", "Берёза", "Дуб") // изменяемый список
mutableTrees.add("Ясень") // всё ок
```
По умолчанию в Kotlin реализацией List является ArrayList, его можно создать напрямую:
```kotlin
val mutableTrees = ArrayList<String>()
mutableTrees.add("Ясень")
```
## Set
Множество — это коллекция уникальных элементов. Это означает, что Set не может содержать дублей. Обратите внимание, что 
null — это тоже уникальный элемент.
```kotlin
val trees = setOf("Сосна", "Берёза", "Дуб") // неизменяемый сет
trees.add("Ясень") // ошибка

val mutableTrees = mutableSetOf("Сосна", "Берёза", "Дуб") // изменяемый сет
mutableTrees.add("Сосна") // проигнорируется
```
В отличие от списка, множество не заботится о порядке элементов. Это означает, что при использовании функций, зависящих
от порядка элементов, вы можете получить непредсказуемый результат. Но это зависит от реализации сета. Например, по
умолчанию реализацией Set является LinkedHashSet, который сохраняет порядок вставки элементов.
```kotlin
val numbers = setOf(1, 2, 3, 4)  // по умолчанию LinkedHashSet
val numbersBackwards = setOf(4, 3, 2, 1)

println(numbers.first() == numbersBackwards.first()) // false
println(numbers.first() == numbersBackwards.last()) // true
```
Но также существует HashSet, который не сохраняет порядок вставки элементов. И LinkedHashSet, и HashSet можно создать
напрямую.
```kotlin
val linkedHashSet = LinkedHashSet<String>()
linkedHashSet.add("Дуб")

val hashSet = HashSet<String>()
hashSet.add("Ясень")
```
## Map
Ассоциативные списки с уникальными ключами и любыми значениями (дубликаты ключей не допускаются, значения могут быть
одинаковыми). Связь между ключами и значениями происходит через специальную форму вызова метода (инфиксный вызов) to.
```kotlin
// числа - это ключи, деревья - значения
val map = mapOf(1 to "Сосна", 2 to "Берёза", 3 to "Дуб") // неизменяемая мапа
map.put(4, "Ясень") // ошибка

val mutableMap = mutableMapOf(1 to "Сосна", 2 to "Берёза", 3 to "Дуб") // изменяемая мапа
mutableMap.put(4, "Ясень")
```
По умолчанию реализацией мапы является LinkedHashMap, который сохраняет порядок вставки записей. Есть ещё HashMap,
которая не сохраняет порядок вставки записей. Обе реализации можно создать напрямую.
```kotlin
val linkedHashMap = LinkedHashMap<Int, String>()
linkedHashMap.put(1, "Дуб")

val hashMap = HashMap<Int, String>()
hashMap.put(1, "Ясень")
```
## Какая из коллекций не является имплементацией Collection?
Интерфейс Map не является наследником интерфейса Collection.

Технически — это не коллекция, так как Map не наследуется от Collection. Но это также структура для хранения данных и ее
всегда изучают и рассматривают вместе с коллекциями. В разговоре вполне нормально называть Map коллекцией.
## Sequences и их отличия от коллекций
Sequences или последовательности — ещё один тип контейнера в Kotlin, но он не является коллекцией. Последовательности 
очень похожи на коллекции, они предоставляют те же функции. Ключевая разница в том, что они применяют другой подход с
многоэтапной обработкой элементов (например, когда вы последовательно вызываете некую цепочку вызовов к коллекции).

Последовательность — это итерируемый тип, с которым можно работать, не создавая ненужных промежуточных коллекций,
выполняя все применимые операции над каждым элементом перед переходом к следующему.

Отличия коллекции от последовательности:
1) Если обработка Iterable состоит из нескольких шагов, то они выполняются немедленно: при завершении обработки каждый
шаг возвращает свой результат — промежуточную коллекцию. Следующий шаг выполняется для этой промежуточной коллекции.
Sequence же по возможности выполняет обработку "лениво" — фактически вычисления происходят только тогда, когда
запрашивается результат выполнения всех шагов.
2) Iterable завершает каждый шаг для всей коллекции, а затем переходит к следующему шагу. Sequence выполняет все шаги 
один за другим для каждого отдельного элемента.
3) Iterable могут занимать больше памяти, чем последовательности, так как они вычисляют все элементы сразу и хранят их
в памяти. Sequence вычисляют элементы при необходимости и не хранят все элементы в памяти.

Зачем вообще нужны Sequences?

Для оптимизации производительности в работе с большими коллекциями (от 1000). Фишка в том, что значения в таких
коллекциях создаются только по мере необходимости, не инициализируя их заранее. Из-за этого нет доступа к содержимому 
по индексу, а также не контролируется размер.

Последовательности позволяют избежать создания промежуточных результатов для каждого шага, тем самым повышая
производительность всей цепочки вызовов. Однако "ленивый" характер последовательностей добавляет некоторые накладные
расходы, которые могут быть значительными при обработке небольших коллекций или при выполнении более простых
вычислений. Следовательно, вы должны рассмотреть, а затем самостоятельно решить, что вам подходит больше — Sequence или
Iterable.

![Operation Chain](https://habrastorage.org/r/w1560/getpro/habr/upload_files/23d/a0e/fba/23da0efba9d5fb49921b3e3c760f4d1d.png)

Создать последовательность можно через функцию sequenceOf():
```kotlin
val cats = sequenceOf("Барсик", "Мурзик", "Рыжик", "Васька")
```
Если у вас есть уже готовые списки List или множества Set, то их можно преобразовать в последовательность через
asSequence():
```kotlin
val cats = listOf("Барсик", "Мурзик", "Рыжик", "Васька")
val catsSequence = cats.asSequence()
```
## Промежуточные и терминальные операции в Sequences
Sequence представляет собой последовательность элементов, которые можно обрабатывать по одному или несколько штук 
сразу. Обработка элементов Sequence происходит с помощью функций высшего порядка, которые называются операциями.

Операции над Sequence можно разделить на две категории: промежуточные (intermediate) и терминальные (terminal).

Промежуточные операции (intermediate) — это операции, которые возвращают новую Sequence.

Они не выполняются немедленно, а лишь формируют новую последовательность элементов на основе исходной. Промежуточные
операции не приводят к запуску вычислений, а готовят данные для последующих операций. Примеры:
- filter(predicate: (T) -> Boolean): фильтрует элементы по заданному условию и возвращает новую Sequence
- map(transform: (T) -> R): преобразует каждый элемент в новый элемент типа R и возвращает новую Sequence
- sortedBy(selector: (T) -> R?): сортирует элементы по заданному ключу и возвращает новую Sequence

Терминальные операции (terminal) — это операции, которые выполняются немедленно и возвращают результат (не Sequence).

Терминальные операции могут быть вызваны только после всех промежуточных операций, так как они завершают
последовательность и начинают вычисление результатов на основе всей последовательности, полученной после выполнения
всех промежуточных операций. Если же терминальная операция вызывается до выполнения всех промежуточных операций, то она
не будет иметь доступа к полной последовательности и вернет неполный результат. Примеры:
- toList(): преобразует Sequence в список
- toSet(): преобразует Sequence в множество
- count(): возвращает количество элементов в Sequence
- forEach(action: (T) -> Unit): выполняет действие для каждого элемента Sequence

ВАЖНО: вычисления запускаются только при вызове терминальной функции (до этого момента никаких вычислений не 
производится).