# Classes and Interfaces
## Оглавление
- [Что такое абстрактные классы и интерфейсы?](#что-такое-абстрактные-классы-и-интерфейсы)
- [Почему классы по умолчанию final?](#почему-классы-по-умолчанию-final)
- [Что нужно сделать, чтобы класс можно было наследовать?](#что-нужно-сделать-чтобы-класс-можно-было-наследовать)
- [Как можно получить тип класса?](#как-можно-получить-тип-класса)
- [Что такое enum?](#что-такое-enum)
- [Что такое sealed?](#что-такое-sealed)
- [Какая разница между sealed и enum?](#какая-разница-между-sealed-и-enum)
- [Что такое inner и nested классы?](#что-такое-inner-и-nested-классы)
- [Value классы](#value-классы)
- [Какая польза от typealias? Во что он компилируется?](#какая-польза-от-typealias-во-что-он-компилируется)
## Что такое абстрактные классы и интерфейсы?
### Абстрактный класс
Абстрактный класс — это класс, представляющий из себя "заготовку" для целого семейства классов, который описывает для 
них общий шаблон поведения. Экземпляр такого класса не может быть создан. Абстрактному классу не нужен модификатор open,
потому что он "открыт" для наследования по умолчанию.

В теле класса можно объявлять абстрактные свойства и функции. Это полезно, когда часть поведения класса не имеет смысла
без реализации в более конкретном подклассе. Каждый наследник обязан переопределять их все.
```kotlin
abstract class Tree {
  abstract val name: String
  abstract val description: String
  abstract fun info()
}

class Pine : Tree() {
    override val name = "Сосна"
    override val description = "Хвойное дерево с длинными иглами и округлыми шишками"
    override fun info() = "$name - ${description.lowercase()}."
}
```
Свойства и функции необязательно должны быть абстрактными. У них может быть обобщенная реализация, которая будет с
пользой наследоваться всеми подклассами. В этом случае для них в абстрактном классе объявляется конкретная реализация,
к которой имеют доступ все наследники.
```kotlin
abstract class Tree {
  abstract val name: String
  abstract val description: String
  fun info(): String = "$name - ${description.lowercase()}."
}

...

class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"
}

...

val pine = Pine()
println(pine.info())
```
Так как этот компонент класса уже не будет абстрактным, наследники не смогут его переопределить.
```kotlin
class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"

  // ошибка: функция "info" является "final" и не может быть переопределена
  override fun info() = description  
}
```
Чтобы это исправить, нужно явно задать модификатор open для функции с конкретной реализацией. Тогда у наследников 
появляется выбор: либо не переопределять функцию и использовать реализацию суперкласса, либо переопределить и указать
свою собственную реализацию.
```kotlin
abstract class Tree {
  abstract val name: String
  abstract val description: String

  open fun info(): String = "$name - ${description.lowercase()}."
}
```
У абстрактного класса может быть конструктор.
```kotlin
abstract class Tree(val name: String, val description: String) {
  open fun info(): String = "$name - ${description.lowercase()}."
}
```
Тогда каждый наследник должен предоставить для него значения.
```kotlin
class Pine(name: String, description: String) : Tree(name, description)

...

val pine = Pine("Сосна", "Хвойное дерево с длинными иглами и округлыми шишками")
println(pine.info())
```
### Интерфейс
Интерфейс — это совокупность методов и правил, которые определяют поведение класса или общее поведение для группы
независимых друг от друга классов. Интерфейсы похожи на абстрактные классы тем, что нельзя создать их экземпляры и они 
могут определять абстрактные или конкретные функции и свойства. Отличие в том, что интерфейсу не важна связь
"родитель-наследник", он задаёт лишь правила поведения.

Интерфейсы в Kotlin могут содержать объявления абстрактных методов, а также методы с реализацией. Главное отличие 
интерфейсов от абстрактных классов заключается в невозможности хранения переменных экземпляров. Они могут иметь
свойства, но те должны быть либо абстрактными, либо предоставлять реализацию методов доступа.

В теле интерфейса можно определять абстрактные свойства и функции. Для этого не требуется использовать ключевое слово
abstract, так как Kotlin способен сам понять, что свойство и функция без реализации должны быть абстрактными. Также
обратите внимание, что единственный способ определить свойство — это определить его в теле интерфейса, так как у
интерфейса не бывает конструкторов.
```kotlin
interface Cultivable {
  val bloom: Boolean
  fun startPhotosynthesis()
}
```
Класс должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе.
```kotlin
abstract class Tree : Cultivable {
  abstract val name: String
  abstract val description: String
  open fun info(): String = "$name - ${description.lowercase()}."

  override val bloom = false
  override fun startPhotosynthesis() {
    ...
  }
}
```
При этом если интерфейс реализовывается в абстрактном классе, то свойства и функции интерфейса могут быть в нём опущены.
Тогда все наследники абстрактного класса должны будут их переопределять.
```kotlin
abstract class Tree : Cultivable {
  abstract val name: String
  abstract val description: String
  open fun info(): String = "$name - ${description.toLowerCase()}."

  override fun startPhotosynthesis() {
    ...
  }
}

class Pine : Tree() {
  override val name = "Сосна"
  override val description = "Хвойное дерево с длинными иглами и округлыми шишками"

  override val bloom = false
}
```
В интерфейсе можно определять свойства и функции с конкретной реализацией (по умолчанию). Классы, реализующие этот
интерфейс, могут использовать реализацию по умолчанию или определить свою. При этом реализация свойств осуществляется с 
помощью метода доступа get().
```kotlin
interface Cultivable {
  val bloom: Boolean
    get() = false

  fun startPhotosynthesis() {
    ...
  }
}
```
Один интерфейс может реализовать другой интерфейс, при этом будет иметь доступ к его свойствам и функциям.
```kotlin
interface Fruitable {
  val fruit: String
    get() = "неплодоносный"
}

interface Cultivable : Fruitable {
  ...

  fun isFruitable() : Boolean {
    if(fruit == "неплодоносный") return false
    return true
  }
}
```
Каждый класс, реализующий интерфейс Cultivable может использовать свойства и функции интерфейса Fruitable, если в этом
есть необходимость.
```kotlin
class AppleTree() : Tree() {
  override val name = "Яблоня"
  override val description = "Фруктовое дерево"
  override val fruit = "яблоко"
}

...

val appleTree = AppleTree()
if(appleTree.isFruitable()) {
  println("Плод - ${appleTree.fruit}.")
} else {
  println("${appleTree.name} не плодоносит.")
}
```
### Что применять: абстрактный класс или интерфейс?
- У вас есть семейство классов, из которых можно выделить общую сущность? Определите эту сущность в качестве
абстрактного класса и она будет “заготовкой” для всего семейства.
- Вам нужно создать более конкретную версию класса? Создайте подкласс этого класса и добавьте недостающее поведение.
- Требуется определить общее поведение для группы независимых друг от друга классов? Создайте интерфейс и реализуйте
его теми классами, которым необходимо это поведение.
### Ключевые моменты
Абстрактный класс — это "заготовка" для целого семейства классов. Нельзя создать экземпляр абстрактного класса. 
Абстрактный класс может содержать как абстрактные, так и конкретные реализации свойств и функций. Класс, который 
содержит абстрактное свойство или функцию, должен быть объявлен абстрактным. Абстрактный класс может быть без единого
абстрактного свойства или функции. У класса может быть только один суперкласс. Наследники абстрактного класса должны
переопределять все его абстрактные свойства и функции. Чтобы наследники могли переопределять конкретные реализации
свойств и функций, для них в абстрактном классе должен быть явно указан модификатор open. У абстрактного класса может
быть конструктор.

Интерфейс определяет поведение класса или общее поведение для группы независимых друг от друга классов. Нельзя создать
экземпляр интерфейса. Интерфейс может содержать как абстрактные, так и конкретные реализации функций. Свойства
интерфейсов могут быть абстрактными, а могут иметь get() методы. Класс может реализовывать несколько интерфейсов. Класс
должен реализовывать все абстрактные свойства и функции, определённые в интерфейсе. Если интерфейс реализовывается
абстрактным классом, то переопределение его абстрактных свойств и функций может быть передано наследникам абстрактного 
класса. Интерфейс может реализовывать другой интерфейс.
## Почему классы по умолчанию final?
Классы в Kotlin по умолчанию являются final для того, чтобы избежать случайного наследования и переопределения методов.
Это сделано для повышения безопасности кода и уменьшения сложности программы, так как ограничение наследования помогает
избежать ошибок, связанных с неожиданным изменением поведения унаследованных методов.

В Kotlin рекомендуется использовать композицию вместо наследования для повторного использования кода и расширения 
функциональности.
## Что нужно сделать, чтобы класс можно было наследовать?
По умолчанию, классы в Kotlin объявляются как final, то есть их нельзя наследовать. Если мы всё же попытаемся
наследоваться от такого класса, то получим ошибку: “This type is final, so it cannot be inherited from”.

Чтобы класс можно было наследовать, его нужно объявить с модификатором open.
```kotlin
open class Fraction {
  ...
}
```
Не только классы, но и функции в Kotlin по умолчанию имеют статус final. Поэтому те функции, которые находятся в
родительском классе и которые вы хотите переопределить в дочерних классах, также должны быть отмечены open.
```kotlin
open class Fraction {

  open fun toAttack() {
    ...
  }

}
```
Свойства класса также по умолчанию являются final. Для возможности переопределения таких свойств в дочерних классах, 
не забудьте и их отметить ключевым словом open.
```kotlin
open class Fraction {

  open val name: String = "default"

  open fun toAttack() {
    ...
  }

}
```
При этом, если в открытом классе будут присутствовать функции и свойства, которые не отмечены словом open, то 
переопределяться они не будут. Но дочерний класс сможет к ним обращаться.
```kotlin
open class Fraction {

  open val name: String = "default"

  fun toAttack() {
    ...
  }

}

class Horde : Fraction() {
  override val name = "Horde"
}

class SomeClass() {
  val horde = Horde()
  horde.toAttack()
}
```
## Как можно получить тип класса?
1) Получение типа класса через функцию ::class. Функция ::class возвращает объект KClass, который содержит информацию о
типе класса во время выполнения:
```kotlin
class Person(val name: String, val age: Int)

fun main() {
    val person = Person("John", 30)
    println(person::class) // выводит "class Person"
}
```
2) Получение типа класса через функцию javaClass. Функция javaClass возвращает объект Class, который содержит
информацию о типе класса во время выполнения:
```kotlin
class Person(val name: String, val age: Int)

fun main() {
    val person = Person("John", 30)
    println(person.javaClass) // выводит "class Person"
}
```
3) Получение типа класса через функцию ::class.java. Вызов функции ::class.java на объекте типа KClass возвращает
объект Class, который содержит информацию о типе класса во время выполнения.
```kotlin
class Person(val name: String, val age: Int)

fun main() {
    val person = Person("John", 30)
    println(person::class.java) // выводит "class Person"
}
```
## Что такое enum?
Если в процессе разработки возникает ситуация, когда переменная должна иметь определённые (заранее известные) 
значения — константы, то вместо того, чтобы плодить список констант, их все можно перечислить в классе, который был
придуман специально для этого — enum (класс перечислений). Он позволяет создать набор значений, которые могут быть
использованы как единственно допустимые значения переменной. Каждая константа в классе перечислений является 
экземпляром этого класса и отделяется от другой константы запятой.
```kotlin
enum class ColorType {
  RED,
  BLUE,
  GREEN
}
```
Чтобы ограничить переменную одним из значений класса перечислений, нужно назначить ей тип объявленного класса 
перечислений:
```kotlin
var color: ColorType
color = ColorType.RED
```
Помимо самих констант в класс перечислений можно добавить свойства и функции. Их необходимо отделять от констант точкой
с запятой. Это единственное место в Kotlin, где используется точка с запятой.
```kotlin
enum class ColorType {
  RED,
  BLUE,
  GREEN;

  fun names() = "Красный, Голубой, Зелёный"
  val rgb = "0xFFFFFF"
}
```
При этом каждая константа сможет обращаться к этому свойству или функции.
```kotlin
var color: ColorType = ColorType.RED
println(color.names()) // выведет "Красный, Голубой, Зелёный"
println(color.rgb) // выведет "0xFFFFFF"
```
Классы перечислений как и обычные классы также могут иметь конструктор. Так как константы являются экземплярами 
enum-класса, они могут быть инициализированы.
```kotlin
enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
```
Enum-константы также могут объявлять свои собственные анонимные классы как с их собственными методами, так и с
перегруженными методами базового класса. Напоминаю, что при объявлении в enum-классе каких-либо членов, необходимо 
отделять их от объявления констант точкой с запятой.
```kotlin
enum class ProtocolState {
    WAITING {
        override fun signal() = TALKING
    },

    TALKING {
        override fun signal() = WAITING
    };

    abstract fun signal(): ProtocolState
}
```
## Что такое sealed?
Sealed class (изолированный класс) — это класс, который является абстрактным и используется в Kotlin для ограничения
классов, которые могут наследоваться от него.

Основная идея заключается в том, что sealed class позволяет определить ограниченный и известный заранее набор
подклассов, которые могут быть использованы.

- Конструктор всегда приватен, и это нельзя изменить
- Могут быть наследники, но все они должны находиться в одном пакете с изолированным классом. Изолированный класс открыт
по умолчанию
- Наследники могут быть классом любого типа (data class, sealed, regular). Классы, расширяющие наследников sealed 
класса, могут находиться где угодно
- Изолированные классы абстрактны и могут содержать в себе абстрактные компоненты
- Нельзя инициализировать
- Не объявляется с ключевым словом inner

```kotlin
sealed class Shape {
    class Circle(val radius: Double) : Shape()
    class Rectangle(val width: Double, val height: Double) : Shape()
    class Triangle(val base: Double, val height: Double) : Shape()
}

fun calculateArea(shape: Shape): Double {
    return when (shape) {
        is Shape.Circle -> Math.PI * shape.radius * shape.radius
        is Shape.Rectangle -> shape.width * shape.height
        is Shape.Triangle -> 0.5 * shape.base * shape.height
    }
}

fun main() {
    val circle = Shape.Circle(5.0)
    val rectangle = Shape.Rectangle(2.0, 3.0)
    val triangle = Shape.Triangle(4.0, 5.0)

    println(calculateArea(circle))     // Output: 78.53981633974483
    println(calculateArea(rectangle))  // Output: 6.0
    println(calculateArea(triangle))   // Output: 10.0
}
```
В этом примере мы определили sealed class Shape, который содержит три класса: Circle, Rectangle и Triangle. Эти классы 
наследуются от Shape. Это означает, что мы можем создавать объекты этих классов и использовать их, как объекты 
типа Shape.

В функции calculateArea мы используем выражение when, чтобы определить тип фигуры и вернуть ее площадь. Таким образом,
если мы передадим Shape.Circle в calculateArea, то будет вычислена площадь круга.

В функции main мы создали объекты Circle, Rectangle и Triangle и передали их в calculateArea, чтобы вычислить их 
площади.
## Какая разница между sealed и enum?
Sealed class и Enum это два разных концепта в Kotlin, хотя их часто используют для ограничения набора возможных
значений. Основная разница между ними:
- enum представляет собой конечный список значений, которые объявляются заранее в момент компиляции, и не могут быть 
расширены или изменены во время выполнения программы
- sealed class позволяет определять ограниченный набор значений, но эти значения могут быть расширены в будущем
## Что такое inner и nested классы?
### Inner classes
Внутренние классы (inner classes) имеют доступ к членам внешнего класса, даже если они объявлены как private.
Внутренний класс является частью внешнего класса и имеет доступ к его свойствам и методам (как если бы вложенный класс 
в Java был не статическим). В Kotlin внутренний класс объявляется с помощью ключевого слова inner. Например:
```kotlin
class Outer {
    private val outerProperty = "Outer Property"
    
    inner class Inner {
        fun innerMethod() {
            println("Accessing outer property: $outerProperty")
        }
    }
}

fun main() {
    Outer().Inner().innerMethod()
}
```
В этом примере Inner является внутренним классом, а Outer является внешним классом. Inner имеет доступ к членам Outer,
в том числе к приватным свойствам и методам, таким как outerProperty.
### Nested classes
Вложенные классы (nested classes) не имеют доступа к членам внешнего класса по умолчанию (как если бы вложенный класс 
в Java был статическим). Они имеют свои собственные члены, которые могут быть использованы только внутри класса.
Например:
```kotlin
class Outer {
    private val outerProperty = "Outer Property"
    
    class Nested {
        fun nestedMethod() {
            println("Accessing nested property")
        }
    }
}

fun main() {
    Outer.Nested().nestedMethod()
}
```
Здесь Nested является вложенным классом. Он не имеет доступа к свойству outerProperty, но может использовать свои
собственные члены, такие как nestedMethod.
## Value классы
В Kotlin версии 1.2.30 была добавлена функциональность inline (встраиваемых) классов. Это позволило создавать классы, 
которые компилируются в обычные примитивы (Int, Long и другие), но при этом могли содержать дополнительные методы и 
свойства.

В Kotlin 1.5 были добавлены value классы (классы значений), которые заменили inline классы. Классы значений
предоставляют те же преимущества, что и inline классы, но с улучшенным синтаксисом и дополнительными возможностями.

В отличие от обычного класса, value класс инлайновый. Он не будет существовать в результирующем байт‑коде приложения. 
Компилятор развернет все value классы и будет использовать вместо них сохраненные внутри значения.

Преимущества:
1) Экономия памяти за счет уменьшения количества объектов, которые создаются в программе. 
2) Улучшение производительности за счет уменьшения количества операций копирования объектов. 
3) Улучшение безопасности за счет возможности установки ограничений на значения свойств value класса.

Ограничения и условия:
1) Класс должен быть помечен аннотацией @JvmInline, чтобы быть оптимизированным компилятором. 
2) Value класс не может иметь перегруженных конструкторов или конструкторов без параметров. 
3) Класс должен иметь одно свойство (только val), инициализированное в основном конструкторе. 
4) Не может быть наследником или наследоваться от другого класса. 
5) Может реализовывать интерфейсы. 
6) Не может быть аннотирован как open, abstract, inner или sealed.

Сравнение и преимущества value над data классами и typealias:
- Делают объявление переменных и сигнатуры функций более выразительными.
- Сохраняют производительность примитивных типов.
- Несовместимы по присваиванию с их базовым типом, предотвращая пользователя от совершения глупых вещей.
- Поддерживают множество особенностей data классов, таких как конструкторы, init, методы и даже дополнительные свойства 
(но только через геттеры).
```kotlin
@JvmInline
value class Age(val age: Int) {
    init {
        require(age >= 0) { "Age cannot be negative" }
    }
}

data class Person(val name: String, val age: Age)

fun main() {
    val person = Person("Alice", Age(30))
    println("Name: ${person.name}, Age: ${person.age.age}")
}
```
В этом примере Age — это value класс, описывающий возраст человека. Он имеет один параметр age, который передается в
конструктор. Затем Age используется в качестве свойства в классе Person. Таким образом, мы можем гарантировать, что
возраст всегда будет неотрицательным, потому что в конструкторе Age используется блок init, проверяющий, что переданный
возраст не меньше нуля.

Возможно, что у вас возникнет вопрос: "Так можно же заменить value класс Age на data класс и все будет работать также.
В чем тогда преимущество в применении здесь value класса?"

Преимущество использования value класса здесь заключается в том, что он позволяет явно выразить намерение разработчика
создать класс, который будет использоваться в качестве значения. Это может помочь в дальнейшей оптимизации кода, так
как компилятор может производить дополнительные оптимизации для value классов, которые недоступны для обычных или data
классов. Также использование value класса Age с аннотацией @JvmInline позволяет избежать создания объекта при обращении 
к значению возраста, что может ускорить выполнение кода. Несмотря на то, что в данном примере это не так очевидно, но
для более сложных и вычислительно затратных операций это может оказаться значительным преимуществом.
## Какая польза от typealias? Во что он компилируется?
Typealias — это механизм создания синонимов (псевдонимов) для существующих типов. То есть, можно создать новое имя для
уже существующего типа данных.

Псевдонимы типов полезны, когда вы хотите сократить длинные имена типов, содержащих обобщения. К примеру, можно 
упрощать названия типов коллекций:
```kotlin
typealias NodeSet = Set<Network.Node>
typealias FileTable<K> = MutableMap<K, MutableList<File>>
```
Польза от использования typealias заключается в том, что он повышает читабельность кода, делает его более выразительным
и удобным для работы. Кроме того, он может упростить процесс переписывания кода в случае изменения типов в будущем.

К примеру, если в проекте используется много Map<String, String> и вместо этого вы хотите использовать более
описательное название, например Properties, вы можете определить новый тип для Map<String, String> с помощью следующего
кода:
```kotlin
typealias Properties = Map<String, String>
```
Теперь вместо использования Map<String, String> можно использовать Properties для обозначения одного и того же типа
данных. Таким образом, код становится более читаемым и понятным.

Typealias не создает новый тип данных, а только создает псевдоним для существующего типа. При компиляции кода, все
typealias заменяются на соответствующий тип, поэтому typealias не приводит к увеличению размера кода.

Например, typealias IntPredicate = (Int) -> Boolean при компиляции будет заменено на (Int) -> Boolean, то есть функцию,
принимающую значение типа Int и возвращающую значение типа Boolean.

Да, можно использовать typealias для функциональных типов в Kotlin. Например, вы можете создать псевдоним для типа
функции, которая принимает два параметра типа Int и возвращает значение типа String, следующим образом:
```kotlin
typealias IntToString = (Int, Int) -> String
```
Это позволит вам использовать созданный псевдоним вместо полного объявления типа, то есть вместо:
```kotlin
fun processValues(f: (Int, Int) -> String) {
    // ...
}
```
можно использовать:
```kotlin
fun processValues(f: IntToString) {
    // ...
}
```
Как и в случае с другими typealias, компилятор Kotlin просто заменяет псевдоним на соответствующий тип при компиляции
кода.